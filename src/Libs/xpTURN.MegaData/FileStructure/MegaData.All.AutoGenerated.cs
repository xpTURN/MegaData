// <auto-generated>
//   This file was generated by a tool; you should avoid making direct changes.
//   Consider using 'partial classes' to extend these types
// </auto-generated>

#region Designer generated code
#nullable disable
using System;
using System.Collections.Generic;

using xpTURN.Common;
using xpTURN.Protobuf;
using xpTURN.Protobuf.Collections;
using static xpTURN.Protobuf.Collections.ProtobufEqualityComparers;
using static xpTURN.Protobuf.CodedOutputStream;
using static xpTURN.Protobuf.xpRepeatedFieldHelper;
using static xpTURN.Protobuf.xpDateTimeUtils;

namespace xpTURN.MegaData
{
    public partial class AliasData : IMessage<AliasData>, IBufferMessage
    {
        #region Proto.Field
        /// <summary>
        /// Desc : Alias Id
        /// </summary>
        public int Id;
        /// <summary>
        /// Desc : Alias Target TableId
        /// </summary>
        public int TableId;
        #endregion

        #region xpTURN.Protobuf.Method
        public AliasData()
        {
        }

        public AliasData(AliasData other) : this()
        {
            Id = other.Id;
            TableId = other.TableId;
        }

        public AliasData Clone()
        {
            return new AliasData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as AliasData);
        }

        public bool Equals(AliasData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Id != other.Id) return false;
            if (TableId != other.TableId) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Id != 0) hash ^= Id.GetHashCode();
            if (TableId != 0) hash ^= TableId.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Id != 0)
            {
                ctx.WriteRawTag(13);
                ctx.WriteSFixed32(Id);
            }
            if (TableId != 0)
            {
                ctx.WriteRawTag(16);
                ctx.WriteInt32(TableId);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Id != 0)
            {
                size += 1 + ComputeSFixed32Size(Id);
            }
            if (TableId != 0)
            {
                size += 1 + ComputeInt32Size(TableId);
            }
            return size;
        }

        public void MergeFrom(AliasData other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Id != 0)
            {
                Id = other.Id;
            }
            if (other.TableId != 0)
            {
                TableId = other.TableId;
            }
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 13:
                        Id = ctx.ReadSFixed32();
                        break;
                    case 16:
                        TableId = ctx.ReadInt32();
                        break;
                }
            }
        }
        #endregion
    }

    public partial class Header : IMessage<Header>, IBufferMessage
    {
        #region Proto.Field
        /// <summary>
        /// Desc : namespace
        /// </summary>
        public string Space = "";
        /// <summary>
        /// Desc : TableSet Name
        /// </summary>
        public string Name = "";
        /// <summary>
        /// Desc : Subset Name
        /// </summary>
        public string Subset = "";
        /// <summary>
        /// Desc : MetaDataTable Hash
        /// </summary>
        public ByteString MetaHash = ByteString.Empty;
        /// <summary>
        /// Desc : DataTables Hash
        /// </summary>
        public ByteString DataHash = ByteString.Empty;
        #endregion

        #region xpTURN.Protobuf.Method
        public Header()
        {
        }

        public Header(Header other) : this()
        {
            Space = other.Space;
            Name = other.Name;
            Subset = other.Subset;
            MetaHash = other.MetaHash;
            DataHash = other.DataHash;
        }

        public Header Clone()
        {
            return new Header(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as Header);
        }

        public bool Equals(Header other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Space != other.Space) return false;
            if (Name != other.Name) return false;
            if (Subset != other.Subset) return false;
            if (MetaHash != other.MetaHash) return false;
            if (DataHash != other.DataHash) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Space.Length != 0) hash ^= Space.GetHashCode();
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            if (Subset.Length != 0) hash ^= Subset.GetHashCode();
            if (MetaHash.Length != 0) hash ^= MetaHash.GetHashCode();
            if (DataHash.Length != 0) hash ^= DataHash.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Space.Length != 0)
            {
                ctx.WriteRawTag(10);
                ctx.WriteString(Space);
            }
            if (Name.Length != 0)
            {
                ctx.WriteRawTag(18);
                ctx.WriteString(Name);
            }
            if (Subset.Length != 0)
            {
                ctx.WriteRawTag(26);
                ctx.WriteString(Subset);
            }
            if (MetaHash.Length != 0)
            {
                ctx.WriteRawTag(34);
                ctx.WriteBytes(MetaHash);
            }
            if (DataHash.Length != 0)
            {
                ctx.WriteRawTag(42);
                ctx.WriteBytes(DataHash);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Space.Length != 0)
            {
                size += 1 + ComputeStringSize(Space);
            }
            if (Name.Length != 0)
            {
                size += 1 + ComputeStringSize(Name);
            }
            if (Subset.Length != 0)
            {
                size += 1 + ComputeStringSize(Subset);
            }
            if (MetaHash.Length != 0)
            {
                size += 1 + ComputeBytesSize(MetaHash);
            }
            if (DataHash.Length != 0)
            {
                size += 1 + ComputeBytesSize(DataHash);
            }
            return size;
        }

        public void MergeFrom(Header other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Space.Length != 0)
            {
                Space = other.Space;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            if (other.Subset.Length != 0)
            {
                Subset = other.Subset;
            }
            if (other.MetaHash.Length != 0)
            {
                MetaHash = other.MetaHash;
            }
            if (other.DataHash.Length != 0)
            {
                DataHash = other.DataHash;
            }
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        Space = ctx.ReadString();
                        break;
                    case 18:
                        Name = ctx.ReadString();
                        break;
                    case 26:
                        Subset = ctx.ReadString();
                        break;
                    case 34:
                        MetaHash = ctx.ReadBytes();
                        break;
                    case 42:
                        DataHash = ctx.ReadBytes();
                        break;
                }
            }
        }
        #endregion
    }

    public partial class MetaData : IMessage<MetaData>, IBufferMessage
    {
        #region Proto.Field
        /// <summary>
        /// Desc : Table Name
        /// </summary>
        public string Name = "";
        /// <summary>
        /// Desc : Table Offset
        /// </summary>
        public long Offset;
        #endregion

        #region xpTURN.Protobuf.Method
        public MetaData()
        {
        }

        public MetaData(MetaData other) : this()
        {
            Name = other.Name;
            Offset = other.Offset;
        }

        public MetaData Clone()
        {
            return new MetaData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as MetaData);
        }

        public bool Equals(MetaData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Name != other.Name) return false;
            if (Offset != other.Offset) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Name.Length != 0) hash ^= Name.GetHashCode();
            if (Offset != 0L) hash ^= Offset.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Name.Length != 0)
            {
                ctx.WriteRawTag(10);
                ctx.WriteString(Name);
            }
            if (Offset != 0L)
            {
                ctx.WriteRawTag(16);
                ctx.WriteInt64(Offset);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Name.Length != 0)
            {
                size += 1 + ComputeStringSize(Name);
            }
            if (Offset != 0L)
            {
                size += 1 + ComputeInt64Size(Offset);
            }
            return size;
        }

        public void MergeFrom(MetaData other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Name.Length != 0)
            {
                Name = other.Name;
            }
            if (other.Offset != 0L)
            {
                Offset = other.Offset;
            }
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        Name = ctx.ReadString();
                        break;
                    case 16:
                        Offset = ctx.ReadInt64();
                        break;
                }
            }
        }
        #endregion
    }

    public partial class MetaDataTable : IMessage<MetaDataTable>, IBufferMessage
    {
        #region Proto.Field
        /// <summary>
        /// Desc : Matching (Alias, Id)
        /// </summary>
        public Dictionary<string, AliasData> MapAliasData = new ();
        /// <summary>
        /// Desc : List MetaData(Table)
        /// </summary>
        public Dictionary<string, MetaData> MapMetaData = new ();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<string, AliasData> _mapAliasData_codec
            = new (xpFieldHelper.StringCodec, xpFieldCodecForMessage<AliasData>.MessageCodec, 10, 10, 18);
        protected static readonly xpMapCodec<string, MetaData> _mapMetaData_codec
            = new (xpFieldHelper.StringCodec, xpFieldCodecForMessage<MetaData>.MessageCodec, 90, 10, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public MetaDataTable()
        {
        }

        public MetaDataTable(MetaDataTable other) : this()
        {
            MapAliasData = _mapAliasData_codec.Clone(other.MapAliasData);
            MapMetaData = _mapMetaData_codec.Clone(other.MapMetaData);
        }

        public MetaDataTable Clone()
        {
            return new MetaDataTable(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as MetaDataTable);
        }

        public bool Equals(MetaDataTable other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (!_mapAliasData_codec.AreEqual(MapAliasData, other.MapAliasData)) return false;
            if (!_mapMetaData_codec.AreEqual(MapMetaData, other.MapMetaData)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= _mapAliasData_codec.GetHashCode(MapAliasData);
            hash ^= _mapMetaData_codec.GetHashCode(MapMetaData);
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            _mapAliasData_codec.WriteTo(ref ctx, ref MapAliasData);
            _mapMetaData_codec.WriteTo(ref ctx, ref MapMetaData);
        }

        public int CalculateSize()
        {
            int size = 0;
            size += _mapAliasData_codec.CalculateSize(MapAliasData);
            size += _mapMetaData_codec.CalculateSize(MapMetaData);
            return size;
        }

        public void MergeFrom(MetaDataTable other)
        {
            if (other == null)
            {
                return;
            }
            _mapAliasData_codec.Merge(MapAliasData, other.MapAliasData);
            _mapMetaData_codec.Merge(MapMetaData, other.MapMetaData);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        _mapAliasData_codec.Read(ref ctx, ref MapAliasData);
                        break;
                    case 90:
                        _mapMetaData_codec.Read(ref ctx, ref MapMetaData);
                        break;
                }
            }
        }
        #endregion
    }

    public partial class MetaNestedData : IMessage<MetaNestedData>, IBufferMessage
    {
        #region Proto.Field
        /// <summary>
        /// Desc : Nested Data Offset by Id
        /// </summary>
        public Dictionary<int, long> MapIdOffset = new ();
        /// <summary>
        /// Desc : Nested Data Offset by Alias
        /// </summary>
        public Dictionary<string, long> MapAliasOffset = new ();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<int, long> _mapIdOffset_codec
            = new (xpFieldHelper.Int32Codec, xpFieldHelper.Int64Codec, 10, 8, 16);
        protected static readonly xpMapCodec<string, long> _mapAliasOffset_codec
            = new (xpFieldHelper.StringCodec, xpFieldHelper.Int64Codec, 18, 10, 16);
        #endregion

        #region xpTURN.Protobuf.Method
        public MetaNestedData()
        {
        }

        public MetaNestedData(MetaNestedData other) : this()
        {
            MapIdOffset = _mapIdOffset_codec.Clone(other.MapIdOffset);
            MapAliasOffset = _mapAliasOffset_codec.Clone(other.MapAliasOffset);
        }

        public MetaNestedData Clone()
        {
            return new MetaNestedData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as MetaNestedData);
        }

        public bool Equals(MetaNestedData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (!_mapIdOffset_codec.AreEqual(MapIdOffset, other.MapIdOffset)) return false;
            if (!_mapAliasOffset_codec.AreEqual(MapAliasOffset, other.MapAliasOffset)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= _mapIdOffset_codec.GetHashCode(MapIdOffset);
            hash ^= _mapAliasOffset_codec.GetHashCode(MapAliasOffset);
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            _mapIdOffset_codec.WriteTo(ref ctx, ref MapIdOffset);
            _mapAliasOffset_codec.WriteTo(ref ctx, ref MapAliasOffset);
        }

        public int CalculateSize()
        {
            int size = 0;
            size += _mapIdOffset_codec.CalculateSize(MapIdOffset);
            size += _mapAliasOffset_codec.CalculateSize(MapAliasOffset);
            return size;
        }

        public void MergeFrom(MetaNestedData other)
        {
            if (other == null)
            {
                return;
            }
            _mapIdOffset_codec.Merge(MapIdOffset, other.MapIdOffset);
            _mapAliasOffset_codec.Merge(MapAliasOffset, other.MapAliasOffset);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        _mapIdOffset_codec.Read(ref ctx, ref MapIdOffset);
                        break;
                    case 18:
                        _mapAliasOffset_codec.Read(ref ctx, ref MapAliasOffset);
                        break;
                }
            }
        }
        #endregion
    }

    public partial class SubsetData : IMessage<SubsetData>, IBufferMessage
    {
        #region Proto.Field
        public List<string> Tables = new ();
        #endregion

        #region xpTURN.Protobuf.Method
        public SubsetData()
        {
        }

        public SubsetData(SubsetData other) : this()
        {
            Tables = RepeatedString().Clone(other.Tables);
        }

        public SubsetData Clone()
        {
            return new SubsetData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as SubsetData);
        }

        public bool Equals(SubsetData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (!RepeatedString().AreEqual(Tables, other.Tables)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= RepeatedString().GetHashCode(Tables);
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            RepeatedString().Write(ref ctx, ref Tables, 10);
        }

        public int CalculateSize()
        {
            int size = 0;
            size += RepeatedString().CalculateSize(Tables, 10);
            return size;
        }

        public void MergeFrom(SubsetData other)
        {
            if (other == null)
            {
                return;
            }
            Tables.AddRange(other.Tables);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        RepeatedString().Read(ref ctx, ref Tables, 10);
                        break;
                }
            }
        }
        #endregion
    }

    public partial class SubsetDataTable : IMessage<SubsetDataTable>, IBufferMessage
    {
        #region Proto.Field
        public Dictionary<string, SubsetData> Map = new ();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<string, SubsetData> _map_codec
            = new (xpFieldHelper.StringCodec, xpFieldCodecForMessage<SubsetData>.MessageCodec, 10, 10, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public SubsetDataTable()
        {
        }

        public SubsetDataTable(SubsetDataTable other) : this()
        {
            Map = _map_codec.Clone(other.Map);
        }

        public SubsetDataTable Clone()
        {
            return new SubsetDataTable(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as SubsetDataTable);
        }

        public bool Equals(SubsetDataTable other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (!_map_codec.AreEqual(Map, other.Map)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= _map_codec.GetHashCode(Map);
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            _map_codec.WriteTo(ref ctx, ref Map);
        }

        public int CalculateSize()
        {
            int size = 0;
            size += _map_codec.CalculateSize(Map);
            return size;
        }

        public void MergeFrom(SubsetDataTable other)
        {
            if (other == null)
            {
                return;
            }
            _map_codec.Merge(Map, other.Map);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        _map_codec.Read(ref ctx, ref Map);
                        break;
                }
            }
        }
        #endregion
    }

}
#nullable restore
#endregion
