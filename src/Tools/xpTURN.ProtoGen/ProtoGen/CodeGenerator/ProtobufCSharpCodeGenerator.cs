using System;
using System.Linq;
using Google.Protobuf.Reflection;

using static xpTURN.ProtoGen.ProtoGenUtils;

namespace xpTURN.ProtoGen
{
    /// <summary>
    /// A code generator that writes C#
    /// </summary>
    public class ProtobufCSharpCodeGenerator : ProtoBuf.Reflection.CSharpCodeGenerator
    {
        /// <summary>
        /// Reusable code-generator instance
        /// </summary>
        public static ProtobufCSharpCodeGenerator DefaultGen { get; } = new ProtobufCSharpCodeGenerator();
        /// <summary>
        /// Create a new xpCSharpCodeGenerator instance
        /// </summary>
        protected ProtobufCSharpCodeGenerator() { }

        protected bool IsMapField(GeneratorContext ctx, FieldDescriptorProto field)
        {
            var mapMsgType = ctx.TryFind<DescriptorProto>(field.TypeName);
            return mapMsgType?.Options?.MapEntry ?? false;
        }

        /// <summary>
        /// Start a file
        /// </summary>
        protected override void WriteFileHeader(GeneratorContext ctx, FileDescriptorProto file, ref object state)
        {
            var tw = ctx;
            tw.WriteLine($"// <auto-generated>");
            tw.WriteLine($"//   This file was generated by a tool; you should avoid making direct changes.");
            tw.WriteLine($"//   Consider using 'partial classes' to extend these types");
            tw.WriteLine($"// </auto-generated>");
            tw.WriteLine();
            tw.WriteLine($"#region Designer generated code");
            tw.WriteLine($"#nullable disable");
            tw.WriteLine($"using System;");
            tw.WriteLine($"using System.Collections.Generic;");
            tw.WriteLine();
            tw.WriteLine($"using xpTURN.Common;");
            tw.WriteLine($"using xpTURN.Protobuf;");
            tw.WriteLine($"using xpTURN.Protobuf.Collections;");
            tw.WriteLine($"using static xpTURN.Protobuf.Collections.ProtobufEqualityComparers;");
            tw.WriteLine($"using static xpTURN.Protobuf.CodedOutputStream;");
            tw.WriteLine($"using static xpTURN.Protobuf.xpRepeatedFieldHelper;");
            tw.WriteLine($"using static xpTURN.Protobuf.xpDateTimeUtils;");
            tw.WriteLine();
        }

        /// <inheritdoc/>
        protected override void WriteNamespaceHeader(GeneratorContext ctx, string @namespace)
        {
            ctx.WriteLine($"namespace {@namespace}");
            ctx.WriteLine($"{{").Indent();
        }

        /// <inheritdoc/>
        protected override void WriteNamespaceFooter(GeneratorContext ctx, string @namespace)
        {
            ctx.Outdent().WriteLine($"}}");
        }

        /// <summary>
        /// End a file
        /// </summary>
        protected override void WriteFileFooter(GeneratorContext ctx, FileDescriptorProto file, ref object state)
        {
            ctx.WriteLine($"#nullable restore");
            ctx.WriteLine($"#endregion");
        }
        /// <summary>
        /// Start an enum
        /// </summary>
        protected override void WriteEnumHeader(GeneratorContext ctx, EnumDescriptorProto @enum, ref object state)
        {
            var name = @enum.Name;
            WriteOptions(ctx, @enum.Options);
            ctx.WriteLine($"{GetAccess(GetAccess(@enum))} enum {Escape(name)}");
            ctx.WriteLine($"{{").Indent();
        }
        /// <summary>
        /// End an enum
        /// </summary>

        protected override void WriteEnumFooter(GeneratorContext ctx, EnumDescriptorProto @enum, ref object state)
        {
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine();
        }
        /// <summary>
        /// Write an enum value
        /// </summary>
        protected override void WriteEnumValue(GeneratorContext ctx, EnumValueDescriptorProto @enum, ref object state)
        {
            var name = @enum.Name;
            WriteOptions(ctx, @enum.Options);
            ctx.WriteLine($"{Escape(name)} = {@enum.Number},");
        }

        /// <summary>
        /// End a message
        /// </summary>
        protected override void WriteMessageFooter(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine();
        }

        /// <summary>
        /// Start a message
        /// </summary>
        protected override void WriteMessageHeader(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            var name = message.Name;
            WriteOptions(ctx, message.Options);
            var tw = ctx.Write($"{GetAccess(GetAccess(message))} partial class {Escape(name)}");
            tw.Write($" : IMessage<{Escape(name)}>, IBufferMessage");
            tw.WriteLine();
            ctx.WriteLine($"{{").Indent();
        }

        private static void WriteOptions(GeneratorContext ctx, EnumOptions obj)
        {
            if (obj == null) return;
            if (obj.Deprecated)
            {
                ctx.WriteLine($"[Obsolete]");
            }
        }

        private static void WriteOptions(GeneratorContext ctx, EnumValueOptions obj)
        {
            if (obj == null) return;
            if (obj.Deprecated)
            {
                ctx.WriteLine($"[Obsolete]");
            }
        }

        private static void WriteOptions(GeneratorContext ctx, MessageOptions obj)
        {
            if (obj == null) return;
            if (obj.Deprecated)
            {
                ctx.WriteLine($"[Obsolete]");
            }
        }

        private static void WriteOptions(GeneratorContext ctx, FieldOptions obj)
        {
            if (obj == null) return;
            if (obj.Deprecated)
            {
                ctx.WriteLine($"[Obsolete]");
            }
        }

        /// <summary>
        /// Emit code beginning a constructor, if one is required
        /// </summary>
        /// <returns>true if a constructor is required</returns>
        protected override bool WriteContructorHeader(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            var name = message.Name;
            ctx.WriteLine($"public {Escape(name)}()") // note: the .ctor is still public even if the type is internal; it is protected by the scope
                .WriteLine($"{{").Indent();
            return true;
        }

        /// <summary>
        /// Emit code terminating a constructor, if one is required
        /// </summary>
        protected override void WriteConstructorFooter(GeneratorContext ctx, DescriptorProto message, ref object state)
        {
            ctx.Outdent().WriteLine($"}}");
        }

        /// <summary>
        /// Emit code initializing field values inside a constructor, if one is required
        /// </summary>
        protected override void WriteInitField(GeneratorContext ctx, FieldDescriptorProto field, ref object state, OneOfStub[] oneOfs)
        {
        }

        protected void WriteFieldTagComment(GeneratorContext ctx, FieldDescriptorProto field, ref object state, OneOfStub[] oneOfs)
        {
            if (IsMapField(ctx, field))
            {
                var mapMsgType = ctx.TryFind<DescriptorProto>(field.TypeName);
                var keyType = mapMsgType.Fields.Single(x => x.Number == 1).type;
                var valueType = mapMsgType.Fields.Single(x => x.Number == 2).type;
                var keyWireType = GetWireType(keyType, false);
                var valueWireType = GetWireType(valueType, false);

                uint keyTag = MakeTag(1, keyWireType);
                uint valueTag = MakeTag(2, valueWireType);

                ctx.WriteLine($"// {Escape(field.Name)}: Tag({field.Tag()}) = {field.Number} << 3 | {(int)field.WireType()}");
                ctx.WriteLine($"//     keyTag({keyTag}) = 1 << 3 | {(int)keyWireType}");
                ctx.WriteLine($"//     valueTag({valueTag}) = 2 << 3 | {(int)valueWireType}");
            }
            else
            {
                ctx.WriteLine($"// {Escape(field.Name)}: Tag({field.Tag()}) = {field.Number} << 3 | {(int)field.WireType()}");
            }
        }

        /// <summary>
        /// Write a field
        /// </summary>
        protected override void WriteField(GeneratorContext ctx, FieldDescriptorProto field, ref object state, OneOfStub[] oneOfs)
        {
            var name = field.Name;
            bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
            var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);
            string __defaultValue = GetCSharpDefaultValue(isRepeated, field.type, field.DefaultValue);
            string defaultValueString = string.IsNullOrEmpty(__defaultValue) ? "" : $" = {__defaultValue}";

            WriteOptions(ctx, field.Options);
            if (isMap)
            {
                var mapMsgType = ctx.TryFind<DescriptorProto>(field.TypeName);
                var keyType = mapMsgType.Fields.Single(x => x.Number == 1).type;
                var valueType = mapMsgType.Fields.Single(x => x.Number == 2).type;
                var keyTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 1),
                    out var keyDataFormat, out var _);
                var valueTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 2),
                    out var valueDataFormat, out var _);

                string csharpKeyTypeName = GetCSharpTypeName(keyType, keyTypeName);
                string csharpValueTypeName = GetCSharpTypeName(valueType, valueTypeName);

                ctx.WriteLine($"public Dictionary<{csharpKeyTypeName}, {csharpValueTypeName}> {Escape(field.Name)} = new ();");
            }
            else if (isRepeated)
            {
                ctx.WriteLine($"{GetAccess(GetAccess(field))} List<{typeName}> {Escape(name)}{defaultValueString};");
            }
            else
            {
                ctx.WriteLine($"{GetAccess(GetAccess(field))} {typeName} {Escape(name)}{defaultValueString};");
            }
        }

        public string GetFieldCodec(FieldDescriptorProto.Type type, string typeName, uint tag)
        {
            string codec = string.Empty;
            string csharpTypeName = GetCSharpTypeName(type, typeName);
            var funcSubName = GetGoogleSubFuncName(type);

            if (type == FieldDescriptorProto.Type.TypeMessage)
            {
                codec = $"xpFieldCodecForMessage<{csharpTypeName}>.{funcSubName}Codec";
            }
            else if (type == FieldDescriptorProto.Type.TypeEnum)
            {
                codec = $"xpFieldCodecForEnum<{csharpTypeName}>.EnumCodec";
            }
            else
            {
                codec = $"xpFieldHelper.{funcSubName}Codec";
            }

            return codec;
        }

        protected void WriteParserField(GeneratorContext ctx, FieldDescriptorProto field, ref object state, OneOfStub[] oneOfs)
        {
            var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);

            if (isMap)
            {
                var mapMsgType = ctx.TryFind<DescriptorProto>(field.TypeName);
                var keyTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 1),
                    out var keyDataFormat, out var _);
                var valueTypeName = GetTypeName(ctx, mapMsgType.Fields.Single(x => x.Number == 2),
                    out var valueDataFormat, out var _);

                var keyType = mapMsgType.Fields.Single(x => x.Number == 1).type;
                var valueType = mapMsgType.Fields.Single(x => x.Number == 2).type;

                string csharpKeyTypeName = GetCSharpTypeName(keyType, keyTypeName);
                string csharpValueTypeName = GetCSharpTypeName(valueType, valueTypeName);

                uint keyTag = MakeTag(1, GetWireType(keyType, false));
                uint valueTag = MakeTag(2, GetWireType(valueType, false));

                string forKeyCodec = GetFieldCodec(keyType, keyTypeName, keyTag);
                string forValueCodec = GetFieldCodec(valueType, valueTypeName, valueTag);

                var name = ToCamelCase(field.Name);
                ctx.WriteLine($"protected static readonly xpMapCodec<{csharpKeyTypeName}, {csharpValueTypeName}> _{ToCamelCase(field.Name)}_codec");
                ctx.Indent().WriteLine($"= new ({forKeyCodec}, {forValueCodec}, {field.Tag()}, {keyTag}, {valueTag});").Outdent();
            }
        }

        protected void WriteFuncCopyConstructor(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public {Escape(name)}({Escape(name)} other) : this()");
            ctx.WriteLine($"{{").Indent();
            foreach (var field in message.Fields)
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
                var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);

                if (isRepeated)
                {
                    var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                    if (mapMsgType != null)
                    {
                        ctx.WriteLine($"{Escape(field.Name)} = _{ToCamelCase(field.Name)}_codec.Clone(other.{Escape(field.Name)});");
                    }
                    else
                    {
                        var funcSubName = GetGoogleSubFuncName(field.type);
                        if (field.type == FieldDescriptorProto.Type.TypeMessage)
                            ctx.WriteLine($"{Escape(field.Name)} = Repeated{funcSubName}<{typeName}>().Clone(other.{Escape(field.Name)});");
                        else if (field.type == FieldDescriptorProto.Type.TypeEnum)
                            ctx.WriteLine($"{Escape(field.Name)} = Repeated{funcSubName}<{typeName}>().Clone(other.{Escape(field.Name)});");
                        else
                            ctx.WriteLine($"{Escape(field.Name)} = Repeated{funcSubName}().Clone(other.{Escape(field.Name)});");
                    }
                }
                else if (field.type == FieldDescriptorProto.Type.TypeMessage)
                {
                    ctx.WriteLine($"if (other.{Escape(field.Name)} != null) {Escape(field.Name)} = other.{Escape(field.Name)}.Clone();");
                }
                else
                {
                    ctx.WriteLine($"{Escape(field.Name)} = other.{Escape(field.Name)};");
                }
            }
            ctx.Outdent().WriteLine($"}}");

        }

        protected void WriteFuncClone(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public {Escape(name)} Clone()");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"return new {Escape(name)}(this);");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncEquals(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public override bool Equals(object other)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"return Equals(other as {Escape(name)});");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncEqualsMessage(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public bool Equals({Escape(name)} other)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"if (ReferenceEquals(other, null)) return false;");
            ctx.WriteLine($"if (ReferenceEquals(other, this)) return true;");
            ctx.WriteLine();
            foreach (var field in message.Fields)
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
                var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);

                if (isRepeated)
                {
                    var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                    if (mapMsgType != null)
                    {
                        ctx.WriteLine($"if (!_{ToCamelCase(field.Name)}_codec.AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                    }
                    else
                    {
                        var funcSubName = GetGoogleSubFuncName(field.type);
                        if (field.type == FieldDescriptorProto.Type.TypeMessage)
                            ctx.WriteLine($"if (!Repeated{funcSubName}<{typeName}>().AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                        else if (field.type == FieldDescriptorProto.Type.TypeEnum)
                            ctx.WriteLine($"if (!Repeated{funcSubName}<{typeName}>().AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                        else
                            ctx.WriteLine($"if (!Repeated{funcSubName}().AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                    }
                }
                else if (field.type == FieldDescriptorProto.Type.TypeMessage)
                {
                    ctx.WriteLine($"if (!object.Equals({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else if (field.type == FieldDescriptorProto.Type.TypeFloat)
                {
                    ctx.WriteLine($"if (!BitwiseSingleEqualityComparer.Equals({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else if (field.type == FieldDescriptorProto.Type.TypeDouble)
                {
                    ctx.WriteLine($"if (!BitwiseDoubleEqualityComparer.Equals({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != other.{Escape(field.Name)}) return false;");
                }
            }
            ctx.WriteLine($"return true;");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncGetHashCode(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public override int GetHashCode()");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"int hash = 1;");
            foreach (var field in message.Fields)
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
                var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);
                string defaultValue = GetCSharpDefaultValueByType(field.type, typeName);
                if (isRepeated)
                {
                    var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                    if (mapMsgType != null)
                    {
                        ctx.WriteLine($"hash ^= _{ToCamelCase(field.Name)}_codec.GetHashCode({Escape(field.Name)});");
                    }
                    else
                    {
                        var funcSubName = GetGoogleSubFuncName(field.type);
                        if (field.type == FieldDescriptorProto.Type.TypeMessage)
                            ctx.WriteLine($"hash ^= Repeated{funcSubName}<{typeName}>().GetHashCode({Escape(field.Name)});");
                        else if (field.type == FieldDescriptorProto.Type.TypeEnum)
                            ctx.WriteLine($"hash ^= Repeated{funcSubName}<{typeName}>().GetHashCode({Escape(field.Name)});");
                        else
                            ctx.WriteLine($"hash ^= Repeated{funcSubName}().GetHashCode({Escape(field.Name)});");
                    }
                }
                else if (field.type == FieldDescriptorProto.Type.TypeMessage)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != null) hash ^= {Escape(field.Name)}.GetHashCode();");
                }
                else if (field.type == FieldDescriptorProto.Type.TypeFloat)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue}) hash ^= BitwiseSingleEqualityComparer.GetHashCode({Escape(field.Name)});");
                }
                else if (field.type == FieldDescriptorProto.Type.TypeDouble)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue}) hash ^= BitwiseDoubleEqualityComparer.GetHashCode({Escape(field.Name)});");
                }
                else if (field.type == FieldDescriptorProto.Type.TypeBytes || field.type == FieldDescriptorProto.Type.TypeString)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)}.Length != 0) hash ^= {Escape(field.Name)}.GetHashCode();");
                }
                else
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue}) hash ^= {Escape(field.Name)}.GetHashCode();");
                }
            }
            ctx.WriteLine($"return hash;");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncWriteToStream(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public void WriteTo(CodedOutputStream output)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"output.WriteRawMessage(this);");
            ctx.Outdent().WriteLine($"}}");

        }

        protected void WriteRawTag(GeneratorContext ctx, uint tag)
        {
            var tagByteCount = GetTagBytes(tag, out var tagBytes);

            if (tagByteCount == 5)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]}, {tagBytes[2]}, {tagBytes[3]}, {tagBytes[4]});");
            else if (tagByteCount == 4)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]}, {tagBytes[2]}, {tagBytes[3]});");
            else if (tagByteCount == 3)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]}, {tagBytes[2]});");
            else if (tagByteCount == 2)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]});");
            else
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]});");
        }

        protected void WriteFuncInternalWriteTo(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"void IBufferMessage.InternalWriteTo(ref WriteContext ctx)");
            ctx.WriteLine($"{{").Indent();
            foreach (var field in message.Fields)
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
                var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);
                string defaultValue = GetCSharpDefaultValueByType(field.type, typeName);
                var funcSubName = GetGoogleSubFuncName(field.type);

                if (isRepeated)
                {
                    var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                    if (mapMsgType != null)
                    {
                        ctx.WriteLine($"_{ToCamelCase(field.Name)}_codec.WriteTo(ref ctx, ref {Escape(field.Name)});");
                    }
                    else
                    {
                        if (field.type == FieldDescriptorProto.Type.TypeMessage)
                            ctx.WriteLine($"Repeated{funcSubName}<{typeName}>().Write(ref ctx, ref {Escape(field.Name)}, {field.Tag()});");
                        else if (field.type == FieldDescriptorProto.Type.TypeEnum)
                            ctx.WriteLine($"Repeated{funcSubName}<{typeName}>().Write(ref ctx, ref {Escape(field.Name)}, {field.Tag()});");
                        else
                            ctx.WriteLine($"Repeated{funcSubName}().Write(ref ctx, ref {field.Name}, {field.Tag()});");
                    }
                }
                else if (field.type == FieldDescriptorProto.Type.TypeMessage)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != null)");
                    ctx.WriteLine($"{{").Indent();
                    WriteRawTag(ctx, field.Tag());
                    ctx.WriteLine($"ctx.WriteMessage({Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
                else
                {
                    if (field.type == FieldDescriptorProto.Type.TypeString || field.type == FieldDescriptorProto.Type.TypeBytes)
                        ctx.WriteLine($"if ({Escape(field.Name)}.Length != 0)");
                    else
                        ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue})");
                    ctx.WriteLine($"{{").Indent();
                    WriteRawTag(ctx, field.Tag());
                    if (field.type == FieldDescriptorProto.Type.TypeEnum)
                        ctx.WriteLine($"ctx.Write{funcSubName}((int){Escape(field.Name)});");
                    else if (field.type == FieldDescriptorProto.Type.TypeDateTime)
                        ctx.WriteLine($"ctx.WriteUInt64({Escape(field.Name)}.GetDateData());");
                    else if (field.type == FieldDescriptorProto.Type.TypeTimeSpan)
                        ctx.WriteLine($"ctx.WriteInt64({Escape(field.Name)}.Ticks);");
                    else if (field.type == FieldDescriptorProto.Type.TypeUri)
                        ctx.WriteLine($"ctx.WriteString({Escape(field.Name)}.ToString());");
                    else if (field.type == FieldDescriptorProto.Type.TypeGuid)
                        ctx.WriteLine($"ctx.WriteString({Escape(field.Name)}.ToString(\"D\"));");
                    else
                        ctx.WriteLine($"ctx.Write{funcSubName}({Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
            }
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncCalculateSize(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public int CalculateSize()");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"int size = 0;");
            foreach (var field in message.Fields)
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
                var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);
                string defaultValue = GetCSharpDefaultValueByType(field.type, typeName);
                var funcSubName = GetGoogleSubFuncName(field.type);

                if (isRepeated)
                {
                    var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                    if (mapMsgType != null)
                    {
                        ctx.WriteLine($"size += _{ToCamelCase(field.Name)}_codec.CalculateSize({Escape(field.Name)});");
                    }
                    else
                    {
                        if (field.type == FieldDescriptorProto.Type.TypeMessage)
                            ctx.WriteLine($"size += Repeated{funcSubName}<{typeName}>().CalculateSize({Escape(field.Name)}, {field.Tag()});");
                        else if (field.type == FieldDescriptorProto.Type.TypeEnum)
                            ctx.WriteLine($"size += Repeated{funcSubName}<{typeName}>().CalculateSize({field.Name}, {field.Tag()});");
                        else
                            ctx.WriteLine($"size += Repeated{funcSubName}().CalculateSize({Escape(field.Name)}, {field.Tag()});");
                    }
                }
                else if (field.type == FieldDescriptorProto.Type.TypeMessage)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != null)");
                    ctx.WriteLine($"{{").Indent();
                    ctx.WriteLine($"size += {GetTagByteCount(field.Tag())} + CodedOutputStream.ComputeMessageSize({Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
                else
                {
                    if (field.type == FieldDescriptorProto.Type.TypeString || field.type == FieldDescriptorProto.Type.TypeBytes)
                        ctx.WriteLine($"if ({Escape(field.Name)}.Length != 0)");
                    else
                        ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue})");
                    ctx.WriteLine($"{{").Indent();
                    if (field.type == FieldDescriptorProto.Type.TypeEnum)
                        ctx.WriteLine($"size += {GetTagByteCount(field.Tag())} + Compute{funcSubName}Size((int){Escape(field.Name)});");
                    else if (field.type == FieldDescriptorProto.Type.TypeDateTime)
                        ctx.WriteLine($"size += {GetTagByteCount(field.Tag())} + ComputeUInt64Size({Escape(field.Name)}.GetDateData());");
                    else if (field.type == FieldDescriptorProto.Type.TypeTimeSpan)
                        ctx.WriteLine($"size += {GetTagByteCount(field.Tag())} + ComputeInt64Size({Escape(field.Name)}.Ticks);");
                    else if (field.type == FieldDescriptorProto.Type.TypeUri)
                        ctx.WriteLine($"size += {GetTagByteCount(field.Tag())} + ComputeStringSize({Escape(field.Name)}.ToString());");
                    else if (field.type == FieldDescriptorProto.Type.TypeGuid)
                        ctx.WriteLine($"size += {GetTagByteCount(field.Tag())} + ComputeStringSize({Escape(field.Name)}.ToString(\"D\"));");
                    else
                        ctx.WriteLine($"size += {GetTagByteCount(field.Tag())} + Compute{funcSubName}Size({Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
            }
            ctx.WriteLine($"return size;");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncMergeFrom(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public void MergeFrom({Escape(name)} other)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"if (other == null)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"return;");
            ctx.Outdent().WriteLine($"}}");
            foreach (var field in message.Fields)
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
                var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);
                string defaultValue = GetCSharpDefaultValueByType(field.type, typeName);

                if (isRepeated)
                {
                    var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                    if (mapMsgType != null)
                    {
                        ctx.WriteLine($"_{ToCamelCase(field.Name)}_codec.Merge({Escape(field.Name)}, other.{Escape(field.Name)});");
                    }
                    else
                    {
                        ctx.WriteLine($"{Escape(field.Name)}.AddRange(other.{Escape(field.Name)});");
                    }
                }
                else if (field.type == FieldDescriptorProto.Type.TypeMessage)
                {
                    ctx.WriteLine($"if (other.{Escape(field.Name)} != null)");
                    ctx.WriteLine($"{{").Indent();
                    ctx.WriteLine($"if ({Escape(field.Name)} == null)");
                    ctx.Indent().WriteLine($"{Escape(field.Name)} = new {typeName}();").Outdent();
                    ctx.WriteLine($"{Escape(field.Name)}.MergeFrom(other.{Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
                else
                {
                    if (field.type == FieldDescriptorProto.Type.TypeString || field.type == FieldDescriptorProto.Type.TypeBytes)
                        ctx.WriteLine($"if (other.{Escape(field.Name)}.Length != 0)");
                    else
                        ctx.WriteLine($"if (other.{Escape(field.Name)} != {defaultValue})");
                    ctx.WriteLine($"{{").Indent();
                    ctx.WriteLine($"{Escape(field.Name)} = other.{Escape(field.Name)};");
                    ctx.Outdent().WriteLine($"}}");
                }
            }
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncMergeFromStream(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"public void MergeFrom(CodedInputStream input)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"input.ReadRawMessage(this);");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncInternalMergeFrom(GeneratorContext ctx, DescriptorProto message)
        {
            var name = message.Name;
            ctx.WriteLine($"void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"uint tag;");
            ctx.WriteLine($"while ((tag = ctx.ReadTag()) != 0)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"if ((tag & 7) == 4)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"// Abort on any end group tag.");
            ctx.WriteLine($"return;");
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine($"switch (tag)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"default:").Indent();
            ctx.WriteLine($"xpParseUtils.SkipLastField(ref ctx);");
            ctx.WriteLine($"break;").Outdent();
            foreach (var field in message.Fields)
            {
                bool isRepeated = field.label == FieldDescriptorProto.Label.LabelRepeated;
                var typeName = GetTypeName(ctx, field, out var dataFormat, out var isMap);
                var funcSubName = GetGoogleSubFuncName(field.type);

                ctx.WriteLine($"case {field.Tag()}:").Indent();
                if (isRepeated)
                {
                    var mapMsgType = isMap ? ctx.TryFind<DescriptorProto>(field.TypeName) : null;
                    if (mapMsgType != null)
                    {
                        ctx.WriteLine($"_{ToCamelCase(field.Name)}_codec.Read(ref ctx, ref {Escape(field.Name)});");
                    }
                    else
                    {
                        if (field.type != FieldDescriptorProto.Type.TypeMessage
                            && field.type != FieldDescriptorProto.Type.TypeString
                            && field.type != FieldDescriptorProto.Type.TypeGuid
                            && field.type != FieldDescriptorProto.Type.TypeUri
                            && field.type != FieldDescriptorProto.Type.TypeBytes)
                        {
                            var subTag = MakeTag(field.Number, GetWireType(field.type, false)); // ValueWireType
                            ctx.Outdent().WriteLine($"case {subTag}:").Indent();
                        }
                        if (field.type == FieldDescriptorProto.Type.TypeMessage)
                            ctx.WriteLine($"Repeated{funcSubName}<{typeName}>().Read(ref ctx, ref {Escape(field.Name)}, {field.Tag()});");
                        else if (field.type == FieldDescriptorProto.Type.TypeEnum)
                            ctx.WriteLine($"Repeated{funcSubName}<{typeName}>().Read(ref ctx, ref {Escape(field.Name)}, {field.Tag()});");
                        else
                            ctx.WriteLine($"Repeated{funcSubName}().Read(ref ctx, ref {Escape(field.Name)}, {field.Tag()});");
                    }
                }
                else if (field.type == FieldDescriptorProto.Type.TypeMessage)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} == null)");
                    ctx.Indent().WriteLine($"{Escape(field.Name)} = new {typeName}();").Outdent();
                    ctx.WriteLine($"ctx.ReadMessage({Escape(field.Name)});");
                }
                else
                {
                    if (field.type == FieldDescriptorProto.Type.TypeEnum)
                        ctx.WriteLine($"{Escape(field.Name)} = ({typeName})ctx.Read{funcSubName}();");
                    else if (field.type == FieldDescriptorProto.Type.TypeDateTime)
                        ctx.WriteLine($"{Escape(field.Name)} = ToDateTime(ctx.ReadUInt64());");
                    else if (field.type == FieldDescriptorProto.Type.TypeTimeSpan)
                        ctx.WriteLine($"{Escape(field.Name)} = TimeSpan.FromTicks(ctx.ReadInt64());");
                    else if (field.type == FieldDescriptorProto.Type.TypeUri)
                        ctx.WriteLine($"{Escape(field.Name)} = new Uri(ctx.ReadString());");
                    else if (field.type == FieldDescriptorProto.Type.TypeGuid)
                        ctx.WriteLine($"{Escape(field.Name)} = Guid.Parse(ctx.ReadString());");
                    else
                        ctx.WriteLine($"{Escape(field.Name)} = ctx.Read{funcSubName}();");
                }
                ctx.WriteLine($"break;").Outdent();
            }
            ctx.Outdent().WriteLine($"}}");
            ctx.Outdent().WriteLine($"}}");
            ctx.Outdent().WriteLine($"}}");
        }

        /// <summary>
        /// Emit code representing a message type
        /// </summary>
        protected override void WriteMessage(GeneratorContext ctx, DescriptorProto message)
        {
            object state = null;
            var oneOfs = new OneOfStub[0];

            if (ShouldOmitMessage(ctx, message, ref state)) return;

            WriteMessageHeader(ctx, message, ref state);

            ctx.WriteLine($"#region Proto.Field");
            if (bool.TryParse(ctx.GetCustomOption("TagComment"), out var tagComment) && tagComment)
            {
                ctx.WriteLine($"// Field definitions for {Escape(message.Name)}");
                foreach (var inner in message.Fields)
                {
                    WriteFieldTagComment(ctx, inner, ref state, oneOfs);
                }
                ctx.WriteLine();
            }

            foreach (var inner in message.Fields)
            {
                WriteField(ctx, inner, ref state, oneOfs);
            }
            ctx.WriteLine($"#endregion");
            ctx.WriteLine();

            bool hasMapFields = message.Fields.Any(field => IsMapField(ctx, field));
            if (hasMapFields)
            {
                ctx.WriteLine($"#region Paser.Field");
                foreach (var inner in message.Fields)
                {
                    WriteParserField(ctx, inner, ref state, oneOfs);
                }
                ctx.WriteLine($"#endregion");
                ctx.WriteLine();
            }

            ctx.WriteLine($"#region xpTURN.Protobuf.Method");
            if (WriteContructorHeader(ctx, message, ref state))
            {
                WriteConstructorFooter(ctx, message, ref state);
            }

            ctx.WriteLine();
            WriteFuncCopyConstructor(ctx, message);
            ctx.WriteLine();
            WriteFuncClone(ctx, message);
            ctx.WriteLine();
            WriteFuncEquals(ctx, message);
            ctx.WriteLine();
            WriteFuncEqualsMessage(ctx, message);
            ctx.WriteLine();
            WriteFuncGetHashCode(ctx, message);
            ctx.WriteLine();
            WriteFuncWriteToStream(ctx, message);
            ctx.WriteLine();
            WriteFuncInternalWriteTo(ctx, message);
            ctx.WriteLine();
            WriteFuncCalculateSize(ctx, message);
            ctx.WriteLine();
            WriteFuncMergeFrom(ctx, message);
            ctx.WriteLine();
            WriteFuncMergeFromStream(ctx, message);
            ctx.WriteLine();
            WriteFuncInternalMergeFrom(ctx, message);
            ctx.WriteLine($"#endregion");

            WriteMessageFooter(ctx, message, ref state);
        }
    }
}
