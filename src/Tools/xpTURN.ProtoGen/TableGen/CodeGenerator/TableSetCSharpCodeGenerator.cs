using System;
using System.Collections.Generic;
using System.Linq;

using xpTURN.Common;

using xpTURN.Tool.Common;
using static xpTURN.TableGen.Utils.TableGenUtils;
using static xpTURN.TableGen.Utils.ProtoTypeUtils;
using System.IO;

namespace xpTURN.TableGen
{
    public class TableSetCSharpCodeGenerator
    {
        SortedList<string, TableDesc> listTableDesc = new SortedList<string, TableDesc>();
        SortedList<string, TableDesc> listDataDesc = new SortedList<string, TableDesc>();

        public TableSetCSharpCodeGenerator()
        {
        }
    
        protected bool IsOndemandTableSet() => listTableDesc.Values.Any(table => table.ParsedExtraOpts.OnDemand);
        protected bool IsWeakRefTableSet() => listTableDesc.Values.Any(table => table.ParsedExtraOpts.WeakRef);

        private int GetTableId(string tableName)
        {
            if (listTableDesc.ContainsKey(tableName))
            {
                // Table IDs start from 1, so we return the count + 1
                return listTableDesc.IndexOfKey(tableName) + 1;
            }

            return 0; // Not found
        }

        protected void WriteFileHeader(GeneratorContext ctx, string spaceName, string tableSetName)
        {
            ctx.WriteLine($"// <auto-generated>");
            ctx.WriteLine($"// This file was generated by a tool; you should avoid making direct changes.");
            ctx.WriteLine($"// Output Name: {tableSetName}");
            ctx.WriteLine($"// </auto-generated>");
            ctx.WriteLine();
            ctx.WriteLine($"#region Designer generated code");
            ctx.WriteLine($"#nullable disable");
            ctx.WriteLine($"using System;");
            ctx.WriteLine($"using System.Collections.Generic;");
            ctx.WriteLine();
            ctx.WriteLine($"using xpTURN.Common;");
            ctx.WriteLine($"using xpTURN.Protobuf;");
            ctx.WriteLine($"using xpTURN.MegaData;");
            ctx.WriteLine();

            if (!string.IsNullOrEmpty(spaceName))
            {
                ctx.WriteLine($"namespace {Escape(spaceName)}");
                ctx.WriteLine($"{{").Indent();
            }
        }

        protected void WriteFileFooter(GeneratorContext ctx)
        {
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine($"#nullable restore");
            ctx.WriteLine($"#endregion");
        }

        protected void WriteTableSetHeader(GeneratorContext ctx, string spaceName, string tableSetName)
        {
            ctx.WriteLine($"public partial class {Escape(tableSetName)} : TableSet");
            ctx.WriteLine($"{{").Indent();
        }

        protected void WriteTableSetFooter(GeneratorContext ctx)
        {
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteSingletonFunction(GeneratorContext ctx, string tableSetName)
        {
            ctx.WriteLine($"private {Escape(tableSetName)}() : base() {{ }}");
            ctx.WriteLine($"public static {Escape(tableSetName)} Instance {{ get; }} = new {Escape(tableSetName)}();");
        }

        protected void WriteRawCreateTableFunction(GeneratorContext ctx)
        {
            ctx.WriteLine($"override protected Table RawCreateTable(int tableId) => tableId switch");
            ctx.WriteLine($"{{").Indent();
            // Generate switch cases for each table
            foreach (var table in listTableDesc.Values)
            {
                int tableId = GetTableId(table.Name);
                ctx.WriteLine($"{tableId} => new {Escape(table.Name)}(),");
            }
            ctx.WriteLine($"_ => null,");
            ctx.Outdent().WriteLine($"}};");
        }

        protected void WriteRawCreateDataFunction(GeneratorContext ctx)
        {
            ctx.WriteLine($"override protected Data RawCreateData(int tableId) => tableId switch");
            ctx.WriteLine($"{{").Indent();
            // Generate switch cases for ondemand tables
            foreach (var table in listTableDesc.Values)
            {
                if (table.IsOnDemand())
                {
                    int tableId = GetTableId(table.Name);
                    var dataName = table.GetNestedDataName();
                    ctx.WriteLine($"{tableId} => new {Escape(dataName)}(), // {table.Name}");
                }
            }
            ctx.WriteLine($"_ => null,");
            ctx.Outdent().WriteLine($"}};");
        }

        protected void WriteTableAliasProperty(GeneratorContext ctx)
        {
            ctx.WriteLine($"override protected SortedDictionary<string, int> TableAlias {{ get; }} = new SortedDictionary<string, int>");
            ctx.WriteLine($"{{").Indent();
            // Generate table alias entries
            foreach (var table in listTableDesc.Values)
            {
                int tableId = GetTableId(table.Name);
                ctx.WriteLine($"{{ nameof({Escape(table.Name)}), {tableId} }},");
            }
            ctx.Outdent().WriteLine($"}};");
        }

        protected void WriteIsOndemandTableFunction(GeneratorContext ctx)
        {
            ctx.WriteLine($"override protected bool IsOndemandTable(int tableId) => tableId switch");
            ctx.WriteLine($"{{").Indent();
            // Generate switch cases for ondemand tables
            foreach (var table in listTableDesc.Values)
            {
                if (table.IsOnDemand())
                {
                    int tableId = GetTableId(table.Name);
                    ctx.WriteLine($"{tableId} => {table.ParsedExtraOpts.OnDemand.ToString().ToLower()}, // {table.Name}");
                }
            }
            ctx.WriteLine($"_ => false,");
            ctx.Outdent().WriteLine($"}};");
        }

        protected void WriteIsWeakRefTableFunction(GeneratorContext ctx)
        {
            ctx.WriteLine($"override protected bool IsWeakRefTable(int tableId) => tableId switch");
            ctx.WriteLine($"{{").Indent();
            // Generate switch cases for weak reference tables
            foreach (var table in listTableDesc.Values)
            {
                if (table.IsWeakRef())
                {
                    int tableId = GetTableId(table.Name);
                    ctx.WriteLine($"{tableId} => {table.ParsedExtraOpts.WeakRef.ToString().ToLower()}, // {table.Name}");
                }
            }
            ctx.WriteLine($"_ => false,");
            ctx.Outdent().WriteLine($"}};");
        }

        protected void WriteTableFunc(GeneratorContext ctx, TableDesc table)
        {
            int tableId = GetTableId(table.Name);
            ctx.WriteLine($"public {Escape(table.Name)} Get{table.Name}() => GetTable({tableId}) as {Escape(table.Name)};");
        }

        protected void WriteDataFunc(GeneratorContext ctx, TableDesc table)
        {
            var nestedField = table.GetNestedField();
            var dataName = table.GetNestedDataName();

            if (table.IsTable && (nestedField == null || string.IsNullOrEmpty(dataName)))
            {
                Logger.Log.Tool.Error(table.DebugInfo, $"Table '{table.Name}' does not have a valid NestedData field.");
                return;
            }

            if (listTableDesc.TryGetValue(dataName, out TableDesc tableDesc))
            {
                Logger.Log.Tool.Warn(table.DebugInfo, $"Data description for '{dataName}' is a table, not a data type.");
                return;
            }

            if (!listDataDesc.TryGetValue(dataName, out TableDesc dataDescValue))
            {
                Logger.Log.Tool.Error(table.DebugInfo, $"Data description for '{dataName}' not found.");
                return;
            }

            int tableId = GetTableId(table.Name);
            string csharpKeyTypeName = GetCSharpTypeName(nestedField.FKeyType, nestedField.FKeyTypeName);
            FieldDesc aliasField = dataDescValue.GetAliasField();

            switch (nestedField.FKeyType)
            {
                case Protobuf.xpFieldTypes.Type_Int32:
                case Protobuf.xpFieldTypes.Type_SInt32:
                case Protobuf.xpFieldTypes.Type_SFixed32:
                    ctx.WriteLine($"public {Escape(dataName)} Get{dataName}(int id) => GetDataById({tableId}, id) as {Escape(dataName)};");
                    break;
                case Protobuf.xpFieldTypes.Type_Enum:
                    ctx.WriteLine($"public {Escape(dataName)} Get{dataName}({csharpKeyTypeName} id) => GetDataById({tableId}, (int)id) as {Escape(dataName)};");
                    break;
                case Protobuf.xpFieldTypes.Type_String:
                    ctx.WriteLine($"public {Escape(dataName)} Get{dataName}({csharpKeyTypeName} alias) => GetDataByAlias({tableId}, alias) as {Escape(dataName)};");
                    break;
                default:
                    Logger.Log.Tool.Error(nestedField.DebugInfo, $"Unsupported key type '{nestedField.FKeyType}' for data '{dataName}'.");
                    break;
            }

            if (aliasField != null && aliasField.FValueType == Protobuf.xpFieldTypes.Type_String)
            {
                ctx.WriteLine($"public {Escape(dataName)} Get{dataName}(string alias) => GetDataById({tableId}, GetId(alias)) as {Escape(dataName)};");
            }
        }

        public string ExportFile(GeneratorContext ctx, string fileName, List<TableDesc> listDesc)
        {
            var nameSpace = ctx.GetCustomOption("Namespace");
            var tableSetName = ctx.GetCustomOption("TableSetName");

            foreach (var desc in listDesc)
            {
                if (!desc.IsMessage)
                    continue;

                if (desc.IsTable)
                    listTableDesc.Add(desc.Name, desc);
                else
                    listDataDesc.Add(desc.Name, desc);
            }

            string generated = string.Empty;
            {
                // Write file header
                WriteFileHeader(ctx, nameSpace, tableSetName);

                WriteTableSetHeader(ctx, nameSpace, tableSetName);

                WriteSingletonFunction(ctx, tableSetName);
                ctx.WriteLine();

                ctx.WriteLine($"#region Get.Method");
                // Iterate through each table definition and write its content
                foreach (var table in listTableDesc.Values)
                {
                    if (table.ParsedExtraOpts.Hide)
                        continue;

                    Logger.Log.Info($"{table.Type.ToString().PadRight(12)}'{table.Name}'");
                    WriteTableFunc(ctx, table);
                }

                ctx.WriteLine();

                // Iterate through each table definition and write its content
                foreach (var table in listTableDesc.Values)
                {
                    if (table.ParsedExtraOpts.Hide)
                        continue;

                    Logger.Log.Info($"{table.Type.ToString().PadRight(12)}'{table.Name}'");
                    WriteDataFunc(ctx, table);
                }
                ctx.WriteLine($"#endregion");

                ctx.WriteLine();
                ctx.WriteLine($"#region Protected.Method");
                WriteRawCreateTableFunction(ctx);
                if (IsOndemandTableSet()) WriteRawCreateDataFunction(ctx);
                WriteTableAliasProperty(ctx);
                if (IsOndemandTableSet()) WriteIsOndemandTableFunction(ctx);
                if (IsWeakRefTableSet()) WriteIsWeakRefTableFunction(ctx);
                ctx.WriteLine($"#endregion");

                WriteTableSetFooter(ctx);

                // Write file footer
                WriteFileFooter(ctx);

                generated = ctx.Output.ToString();
            }

            //
            using (var writer = File.CreateText(fileName))
            {
                writer.Write(generated);
            }

            return MD5Utils.ComputeMD5Hash(generated);
        }
    }
}
