using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;

using xpTURN.Common;
using xpTURN.Protobuf;
using xpTURN.MegaData;

using xpTURN.Tool.Common;
using static xpTURN.TableGen.Utils.TableGenUtils;
using static xpTURN.TableGen.Utils.ProtoTypeUtils;

namespace xpTURN.TableGen
{
    public class ProtobufCSharpCodeGenerator : ICodeGenerator
    {
        private List<TableDesc> _listTable;

        public ProtobufCSharpCodeGenerator()
        {
        }

        protected bool CheckGetterType(string getterType) => _listTable.Any(t => t.Name == getterType);

        protected string GetMapKeySubName(xpFieldTypes keyType)
        {
            switch(keyType)
            {
                case xpFieldTypes.Type_Int32:
                case xpFieldTypes.Type_SInt32:
                case xpFieldTypes.Type_SFixed32:
                    return "Int";
                case xpFieldTypes.Type_Enum:
                    return "Enum";
                case xpFieldTypes.Type_String:
                    return "String";
                default:
                    throw new ArgumentException($"Unsupported key type: {keyType}");
            }
        }

        protected void WriteComments(GeneratorContext ctx, TableDesc tableDef)
        {
            if (!ctx.IsEnabled("OutputComment")) return;

            if (string.IsNullOrEmpty(tableDef.Desc))
            {
                return;
            }

            string[] descLines = tableDef.Desc.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.RemoveEmptyEntries);

            ctx.WriteLine($"/// <summary>");

            if (descLines.Length > 0)
            {
                for (int i = 0; i < descLines.Length; ++i)
                {
                    if (i == 0)
                        ctx.WriteLine($"/// Desc : {ConvertSpecialCharacters(descLines[i])}");
                    else
                        ctx.WriteLine($"/// {ConvertSpecialCharacters(descLines[i])}");
                }
            }

            ctx.WriteLine($"/// </summary>");
        }

        protected void WriteComments(GeneratorContext ctx, FieldDesc fieldDef)
        {
            if (!ctx.IsEnabled("OutputComment")) return;

            if (string.IsNullOrEmpty(fieldDef.Desc))
            {
                return;
            }

            string[] descLines = fieldDef.Desc.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.RemoveEmptyEntries);

            ctx.WriteLine($"/// <summary>");

            if (descLines.Length > 0)
            {
                for (int i = 0; i < descLines.Length; ++i)
                {
                    if (i == 0)
                        ctx.WriteLine($"/// Desc : {ConvertSpecialCharacters(descLines[i])}");
                    else
                        ctx.WriteLine($"/// {ConvertSpecialCharacters(descLines[i])}");
                }
            }

            ctx.WriteLine($"/// </summary>");
        }

        public void WriteFileHeader(GeneratorContext ctx)
        {
            var nameSpace = ctx.GetCustomOption("Namespace");
            var tableSetName = ctx.GetCustomOption("TableSetName");

            ctx.WriteLine($"// <auto-generated>");
            ctx.WriteLine($"//   This file was generated by a tool; you should avoid making direct changes.");
            ctx.WriteLine($"//   Consider using 'partial classes' to extend these types");
            ctx.WriteLine($"// </auto-generated>");
            ctx.WriteLine();
            ctx.WriteLine($"#region Designer generated code");
            ctx.WriteLine($"#nullable disable");
            ctx.WriteLine($"using System;");
            ctx.WriteLine($"using System.Collections.Generic;");
            if (ctx.IsEnabled("ForDataTable"))
            {
                ctx.WriteLine($"using System.Runtime.Serialization;");
            }
            ctx.WriteLine();
            ctx.WriteLine($"using xpTURN.Common;");
            ctx.WriteLine($"using xpTURN.Protobuf;");
            ctx.WriteLine($"using xpTURN.Protobuf.Collections;");
            ctx.WriteLine($"using static xpTURN.Protobuf.Collections.ProtobufEqualityComparers;");
            ctx.WriteLine($"using static xpTURN.Protobuf.CodedOutputStream;");
            ctx.WriteLine($"using static xpTURN.Protobuf.xpRepeatedFieldHelper;");
            ctx.WriteLine($"using static xpTURN.Protobuf.xpDateTimeUtils;");
            if (ctx.IsEnabled("ForDataTable"))
            {
                ctx.WriteLine($"using xpTURN.MegaData;");
                ctx.WriteLine($"using static {nameSpace}.{tableSetName};");
            }

            ctx.WriteLine();

            if (!string.IsNullOrEmpty(nameSpace))
            {
                ctx.WriteLine($"namespace {Escape(nameSpace)}");
                ctx.WriteLine($"{{").Indent();
            }
        }

        public void WriteFileFooter(GeneratorContext ctx)
        {
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine($"#nullable restore");
            ctx.WriteLine($"#endregion");
        }

        public void WriteEnumHeader(GeneratorContext ctx, TableDesc tableDef)
        {
            if (tableDef.Obsolete == FieldObsolete.Warning)
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\")]");
            else if (tableDef.Obsolete == FieldObsolete.Error)
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\", true)]");

            ctx.WriteLine($"public enum {Escape(tableDef.Name)}");
            ctx.WriteLine($"{{").Indent();
        }

        public void WriteEnumValue(GeneratorContext ctx, FieldDesc fieldDef)
        {
            if (fieldDef.Obsolete == FieldObsolete.Warning)
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\")]");
            else if (fieldDef.Obsolete == FieldObsolete.Error)
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\", true)]");

            ctx.WriteLine($"{Escape(fieldDef.Name)} = {fieldDef.Num},");
        }

        public void WriteEnumFooter(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine();
        }

        public void WriteEnum(GeneratorContext ctx, TableDesc tableDef)
        {
            WriteComments(ctx, tableDef);
            WriteEnumHeader(ctx, tableDef);

            foreach (var field in tableDef.GetListField())
            {
                WriteComments(ctx, field);
                WriteEnumValue(ctx, field);
            }

            WriteEnumFooter(ctx, tableDef);
        }

        public void WriteMessageHeader(GeneratorContext ctx, TableDesc desc)
        {
            if (desc.Obsolete == FieldObsolete.Warning)
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\")]");
            else if (desc.Obsolete == FieldObsolete.Error)
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\", true)]");

            if (ctx.IsEnabled("ForDataTable"))
            {
                if (desc.IsTable)
                {
                    ctx.WriteLine($"public partial class {Escape(desc.Name)} : Table, IMessage<{Escape(desc.Name)}>, IBufferMessage");
                }
                else
                {
                    ctx.WriteLine($"public partial class {Escape(desc.Name)} : Data, IMessage<{Escape(desc.Name)}>, IBufferMessage");
                }
            }
            else
            {
                ctx.WriteLine($"public partial class {Escape(desc.Name)} : IMessage<{Escape(desc.Name)}>, IBufferMessage");
            }

            ctx.WriteLine($"{{").Indent();
        }

        protected void WriteMetaNestedDataSetup(GeneratorContext ctx, TableDesc tableDef)
        {
            if (!ctx.IsEnabled("ForDataTable"))
                return;

            if (!tableDef.IsTable)
                return;

            FieldDesc mapField = tableDef.GetNestedField();
            if (mapField != null)
            {
                string csharpKeyTypeName = GetCSharpTypeName(mapField.FKeyType, mapField.FKeyTypeName);
                string csharpValueTypeName = GetCSharpTypeName(mapField.FValueType, mapField.FValueTypeName);

                var subName = GetMapKeySubName(mapField.FKeyType);
                var keyValueString = mapField.FKeyType == xpFieldTypes.Type_Enum
                    ? $"{csharpKeyTypeName}, {csharpValueTypeName}"
                    : csharpValueTypeName;
                var mapWrapper = $"new Map{subName}Wrapper<{keyValueString}>({Escape(mapField.Name)})";
                var interfaceSubName = mapField.FKeyType == xpFieldTypes.Type_String ? "String" : "Int";
                var isWeakRef = tableDef.IsWeakRef().ToString().ToLower();

                if (!tableDef.IsWeakRef())
                    ctx.WriteLine($"MetaNestedData.Setup{interfaceSubName}Wrapper({mapWrapper});");
                else
                    ctx.WriteLine($"MetaNestedData.Setup{interfaceSubName}Wrapper({mapWrapper}, Instance.EnableWeakRef);");
            }
        }

        protected void WriteGetterSetup(GeneratorContext ctx, TableDesc tableDef)
        {
            if (!ctx.IsEnabled("ForDataTable"))
                return;

            foreach (var field in tableDef.GetListField())
            {
                if (string.IsNullOrEmpty(field.ParsedExtraOpts.Get))
                    continue;

                if (!field.Name.EndsWith(sRefID))
                {
                    Logger.Log.Tool.Error(field.DebugInfo, $"Field '{field.Name}' does not end with '{sRefID}'. The 'Get' option is only valid for fields ending with '{sRefID}'.");
                    continue;
                }

                var getType = Escape(field.ParsedExtraOpts.Get.Trim());
                var propName = Escape(field.Name.Substring(0, field.Name.Length - sRefID.Length));
                if (tableDef.GetListField().Any(f => f.Name == propName))
                {
                    Logger.Log.Tool.Error(field.DebugInfo, $"Property name '{propName}' conflicts with another field.");
                    continue;
                }

                if (field.Collections == FieldCollections.List && TableTypeUtils.IsIntKeyType(field.FValueType))
                {
                    ctx.WriteLine($"{propName}.RefList = {field.Name};");
                }
            }
        }

        protected void WriteFuncConstructor(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public {Escape(tableDef.Name)}()");
            ctx.WriteLine($"{{").Indent();
            WriteMetaNestedDataSetup(ctx, tableDef);
            WriteGetterSetup(ctx, tableDef);
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncCopyConstructor(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public {Escape(tableDef.Name)}({Escape(tableDef.Name)} other) : this()");
            ctx.WriteLine($"{{").Indent();

            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                if (field.Collections == FieldCollections.List)
                {
                    var funcSubName = GetGoogleTypeName(field.FValueType);
                    if (field.FValueType == xpFieldTypes.Type_Message)
                        ctx.WriteLine($"{Escape(field.Name)} = Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().Clone(other.{Escape(field.Name)});");
                    else if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"{Escape(field.Name)} = Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().Clone(other.{Escape(field.Name)});");
                    else
                        ctx.WriteLine($"{Escape(field.Name)} = Repeated{funcSubName}().Clone(other.{Escape(field.Name)});");
                }
                else if (field.Collections == FieldCollections.Map)
                {
                    ctx.WriteLine($"{Escape(field.Name)} = _{ToCamelCase(field.Name)}_codec.Clone(other.{Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_Message)
                {
                    ctx.WriteLine($"if (other.{Escape(field.Name)} != null) {Escape(field.Name)} = other.{Escape(field.Name)}.Clone();");
                }
                else
                {
                    ctx.WriteLine($"{Escape(field.Name)} = other.{Escape(field.Name)};");
                }
            }

            WriteMetaNestedDataSetup(ctx, tableDef);
            WriteGetterSetup(ctx, tableDef);

            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncClone(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public {Escape(tableDef.Name)} Clone()");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"return new {Escape(tableDef.Name)}(this);");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncEquals(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public override bool Equals(object other)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"return Equals(other as {Escape(tableDef.Name)});");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncEqualsMessage(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public bool Equals({Escape(tableDef.Name)} other)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"if (ReferenceEquals(other, null)) return false;");
            ctx.WriteLine($"if (ReferenceEquals(other, this)) return true;");
            ctx.WriteLine();

            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                if (field.Collections == FieldCollections.List)
                {
                    var funcSubName = GetGoogleTypeName(field.FValueType);
                    if (field.FValueType == xpFieldTypes.Type_Message)
                        ctx.WriteLine($"if (!Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                    else if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"if (!Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                    else
                        ctx.WriteLine($"if (!Repeated{funcSubName}().AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else if (field.Collections == FieldCollections.Map)
                {
                    ctx.WriteLine($"if (!_{ToCamelCase(field.Name)}_codec.AreEqual({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else if (field.FValueType == xpFieldTypes.Type_Message)
                {
                    ctx.WriteLine($"if (!object.Equals({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else if (field.FValueType == xpFieldTypes.Type_Float)
                {
                    ctx.WriteLine($"if (!BitwiseSingleEqualityComparer.Equals({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else if (field.FValueType == xpFieldTypes.Type_Double)
                {
                    ctx.WriteLine($"if (!BitwiseDoubleEqualityComparer.Equals({Escape(field.Name)}, other.{Escape(field.Name)})) return false;");
                }
                else
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != other.{Escape(field.Name)}) return false;");
                }
            }
            ctx.WriteLine($"return true;");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncGetHashCode(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public override int GetHashCode()");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"int hash = 1;");
            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                string defaultValue;
                if (!GetCSharpDefaultValueByType(field.FValueType, field.FValueTypeName, out defaultValue))
                {
                    Logger.Log.Tool.Error(field.DebugInfo, $"Unknown Default Value '{field.Default}'");
                }

                if (field.Collections == FieldCollections.List)
                {
                    var funcSubName = GetGoogleTypeName(field.FValueType);
                    if (field.FValueType == xpFieldTypes.Type_Message)
                        ctx.WriteLine($"hash ^= Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().GetHashCode({Escape(field.Name)});");
                    else if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"hash ^= Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().GetHashCode({Escape(field.Name)});");
                    else
                        ctx.WriteLine($"hash ^= Repeated{funcSubName}().GetHashCode({Escape(field.Name)});");
                }
                else if (field.Collections == FieldCollections.Map)
                {
                    ctx.WriteLine($"hash ^= _{ToCamelCase(field.Name)}_codec.GetHashCode({Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_Message)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != null) hash ^= {Escape(field.Name)}.GetHashCode();");
                }
                else if (field.FValueType == xpFieldTypes.Type_Float)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue}) hash ^= BitwiseSingleEqualityComparer.GetHashCode({Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_Double)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue}) hash ^= BitwiseDoubleEqualityComparer.GetHashCode({Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_String || field.FValueType == xpFieldTypes.Type_Bytes)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)}.Length != 0) hash ^= {Escape(field.Name)}.GetHashCode();");
                }
                else
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue}) hash ^= {Escape(field.Name)}.GetHashCode();");
                }
            }
            ctx.WriteLine($"return hash;");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncWriteToStream(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public void WriteTo(CodedOutputStream output)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"output.WriteRawMessage(this);");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteRawTag(GeneratorContext ctx, uint tag)
        {
            var tagByteCount = GetTagBytes(tag, out List<byte> tagBytes);

            if (tagByteCount == 5)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]}, {tagBytes[2]}, {tagBytes[3]}, {tagBytes[4]});");
            else if (tagByteCount == 4)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]}, {tagBytes[2]}, {tagBytes[3]});");
            else if (tagByteCount == 3)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]}, {tagBytes[2]});");
            else if (tagByteCount == 2)
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]}, {tagBytes[1]});");
            else
                ctx.WriteLine($"ctx.WriteRawTag({tagBytes[0]});");
        }

        protected void WriteFuncInternalWriteTo(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"void IBufferMessage.InternalWriteTo(ref WriteContext ctx)");
            ctx.WriteLine($"{{").Indent();
            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                var typeName = GetCSharpTypeName(field.FValueType, field.FValueTypeName);
                var funcSubName = GetGoogleTypeName(field.FValueType);

                string defaultValue;
                if (!GetCSharpDefaultValueByType(field.FValueType, field.FValueTypeName, out defaultValue))
                {
                    Logger.Log.Tool.Error(field.DebugInfo, $"Unknown Default Value '{field.Default}'");
                }

                if (field.Collections == FieldCollections.List)
                {
                    if (field.FValueType == xpFieldTypes.Type_Message)
                        ctx.WriteLine($"Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().Write(ref ctx, ref {Escape(field.Name)}, {field.Tag});");
                    else if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().Write(ref ctx, ref {Escape(field.Name)}, {field.Tag});");
                    else
                        ctx.WriteLine($"Repeated{funcSubName}().Write(ref ctx, ref {Escape(field.Name)}, {field.Tag});");
                }
                else if (field.Collections == FieldCollections.Map)
                {
                    ctx.WriteLine($"_{ToCamelCase(field.Name)}_codec.WriteTo(ref ctx, ref {Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_Message)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != null)");
                    ctx.WriteLine($"{{").Indent();

                    WriteRawTag(ctx, field.Tag);
                
                    ctx.WriteLine($"ctx.WriteMessage({Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
                else
                {
                    if (field.FValueType == xpFieldTypes.Type_String || field.FValueType == xpFieldTypes.Type_Bytes)
                        ctx.WriteLine($"if ({Escape(field.Name)}.Length != 0)");
                    else
                        ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue})");

                    ctx.WriteLine($"{{").Indent();

                    WriteRawTag(ctx, field.Tag);

                    if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"ctx.Write{funcSubName}((int){Escape(field.Name)});");
                    else if (field.FValueType == xpFieldTypes.Type_DateTime)
                        ctx.WriteLine($"ctx.WriteUInt64({Escape(field.Name)}.GetDateData());");
                    else if (field.FValueType == xpFieldTypes.Type_TimeSpan)
                        ctx.WriteLine($"ctx.WriteInt64({Escape(field.Name)}.Ticks);");
                    else if (field.FValueType == xpFieldTypes.Type_Uri)
                        ctx.WriteLine($"ctx.WriteString({Escape(field.Name)}.ToString());");
                    else if (field.FValueType == xpFieldTypes.Type_Guid)
                        ctx.WriteLine($"ctx.WriteString({Escape(field.Name)}.ToString(\"D\"));");
                    else
                        ctx.WriteLine($"ctx.Write{funcSubName}({Escape(field.Name)});");

                    ctx.Outdent().WriteLine($"}}");
                }
            }

            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncCalculateSize(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public int CalculateSize()");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"int size = 0;");

            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                var funcSubName = GetGoogleTypeName(field.FValueType);
                if (field.Collections == FieldCollections.List)
                {
                    if (field.FValueType == xpFieldTypes.Type_Message)
                        ctx.WriteLine($"size += Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().CalculateSize({Escape(field.Name)}, {field.Tag});");
                    else if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"size += Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().CalculateSize({Escape(field.Name)}, {field.Tag});");
                    else
                        ctx.WriteLine($"size += Repeated{funcSubName}().CalculateSize({Escape(field.Name)}, {field.Tag});");
                }
                else if (field.Collections == FieldCollections.Map)
                {
                    ctx.WriteLine($"size += _{ToCamelCase(field.Name)}_codec.CalculateSize({Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_Message)
                {
                    ctx.WriteLine($"if ({Escape(field.Name)} != null)");
                    ctx.WriteLine($"{{").Indent();
                    ctx.WriteLine($"size += {GetTagByteCount(field.Tag)} + CodedOutputStream.ComputeMessageSize({Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
                else
                {
                    var defaultValue = string.Empty;
                    if (!GetCSharpDefaultValueByType(field.FValueType, field.FValueTypeName, out defaultValue))
                    {
                        Logger.Log.Tool.Error(field.DebugInfo, $"Unknown Default Value '{field.Default}'");
                    }

                    if (field.FValueType == xpFieldTypes.Type_String || field.FValueType == xpFieldTypes.Type_Bytes)
                        ctx.WriteLine($"if ({Escape(field.Name)}.Length != 0)");
                    else
                        ctx.WriteLine($"if ({Escape(field.Name)} != {defaultValue})");

                    ctx.WriteLine($"{{").Indent();
                    switch (field.FValueType)
                    {
                        case xpFieldTypes.Type_Enum:
                            ctx.WriteLine($"size += {GetTagByteCount(field.Tag)} + Compute{funcSubName}Size((int){Escape(field.Name)});");
                            break;
                        case xpFieldTypes.Type_Bool:
                        case xpFieldTypes.Type_Int32:
                        case xpFieldTypes.Type_UInt32:
                        case xpFieldTypes.Type_SInt32:
                        case xpFieldTypes.Type_Int64:
                        case xpFieldTypes.Type_UInt64:
                        case xpFieldTypes.Type_SInt64:
                        case xpFieldTypes.Type_Fixed32:
                        case xpFieldTypes.Type_SFixed32:
                        case xpFieldTypes.Type_Float:
                        case xpFieldTypes.Type_Fixed64:
                        case xpFieldTypes.Type_SFixed64:
                        case xpFieldTypes.Type_Double:
                        case xpFieldTypes.Type_String:
                        case xpFieldTypes.Type_Bytes:
                            ctx.WriteLine($"size += {GetTagByteCount(field.Tag)} + Compute{funcSubName}Size({Escape(field.Name)});");
                            break;

                        case xpFieldTypes.Type_DateTime:
                            ctx.WriteLine($"size += {GetTagByteCount(field.Tag)} + ComputeUInt64Size({Escape(field.Name)}.GetDateData());");
                            break;
                        case xpFieldTypes.Type_TimeSpan:
                            ctx.WriteLine($"size += {GetTagByteCount(field.Tag)} + ComputeInt64Size({Escape(field.Name)}.Ticks);");
                            break;
                        case xpFieldTypes.Type_Uri:
                            ctx.WriteLine($"size += {GetTagByteCount(field.Tag)} + ComputeStringSize({Escape(field.Name)}.ToString());");
                            break;
                        case xpFieldTypes.Type_Guid:
                            ctx.WriteLine($"size += {GetTagByteCount(field.Tag)} + ComputeStringSize({Escape(field.Name)}.ToString(\"D\"));");
                            break;

                        default:
                            throw new ArgumentException($"Unsupported field type: {field.FValueType}");
                    }

                    ctx.Outdent().WriteLine($"}}");
                }
            }

            ctx.WriteLine($"return size;");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncMergeFrom(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public void MergeFrom({Escape(tableDef.Name)} other)");
            ctx.WriteLine($"{{").Indent();

            ctx.WriteLine($"if (other == null)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"return;");
            ctx.Outdent().WriteLine($"}}");

            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                if (field.Collections == FieldCollections.List)
                {
                    ctx.WriteLine($"{Escape(field.Name)}.AddRange(other.{Escape(field.Name)});");
                }
                else if (field.Collections == FieldCollections.Map)
                {
                    ctx.WriteLine($"_{ToCamelCase(field.Name)}_codec.Merge({Escape(field.Name)}, other.{Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_Message)
                {
                    ctx.WriteLine($"if (other.{Escape(field.Name)} != null)");
                    ctx.WriteLine($"{{").Indent();
                    ctx.WriteLine($"if ({Escape(field.Name)} == null)").Indent();
                    ctx.WriteLine($"{Escape(field.Name)} = new {Escape(field.FValueTypeName)}();").Outdent();
                    ctx.WriteLine($"{Escape(field.Name)}.MergeFrom(other.{Escape(field.Name)});");
                    ctx.Outdent().WriteLine($"}}");
                }
                else
                {
                    var typeGName = GetGoogleTypeName(field.FValueType);
                    var defaultValue = string.Empty;
                    if (!GetCSharpDefaultValueByType(field.FValueType, field.FValueTypeName, out defaultValue))
                    {
                        Logger.Log.Tool.Error(field.DebugInfo, $"Unknown Default Value '{field.Default}'");
                    }

                    if (field.FValueType == xpFieldTypes.Type_String || field.FValueType == xpFieldTypes.Type_Bytes)
                        ctx.WriteLine($"if (other.{Escape(field.Name)}.Length != 0)");
                    else
                        ctx.WriteLine($"if (other.{Escape(field.Name)} != {defaultValue})");

                    ctx.WriteLine($"{{").Indent();
                    ctx.WriteLine($"{Escape(field.Name)} = other.{Escape(field.Name)};");
                    ctx.Outdent().WriteLine($"}}");
                }
            }

            // Since the converter uses Map directly, you need to call Merge.
            if (ctx.IsEnabled("ForDataTable") && tableDef.IsOnDemand())
            {
                FieldDesc nestedField = tableDef.GetNestedField();
                ctx.WriteLine();
                ctx.WriteLine($"_{ToCamelCase(nestedField.Name)}_codec.Merge({Escape(nestedField.Name)}, other.{Escape(nestedField.Name)});");
            }

            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncMergeFromStream(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"public void MergeFrom(CodedInputStream input)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"input.ReadRawMessage(this);");
            ctx.Outdent().WriteLine($"}}");
        }

        protected void WriteFuncInternalMergeFrom(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"uint tag;");
            ctx.WriteLine($"while ((tag = ctx.ReadTag()) != 0)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"if ((tag & 7) == 4)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"// Abort on any end group tag.");
            ctx.WriteLine($"return;");
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine($"switch (tag)");
            ctx.WriteLine($"{{").Indent();
            ctx.WriteLine($"default:").Indent();
            ctx.WriteLine($"xpParseUtils.SkipLastField(ref ctx);");
            ctx.WriteLine($"break;").Outdent();
            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                var funcSubName = GetGoogleTypeName(field.FValueType);
                ctx.WriteLine($"case {field.Tag}:").Indent();
                if (field.Collections == FieldCollections.List)
                {
                    if (field.FValueType != xpFieldTypes.Type_Message
                        && field.FValueType != xpFieldTypes.Type_String
                        && field.FValueType != xpFieldTypes.Type_Guid
                        && field.FValueType != xpFieldTypes.Type_Uri
                        && field.FValueType != xpFieldTypes.Type_Bytes)
                    {
                        var subTag = WireFormat.MakeTag(field.Num, field.ValueWireType);
                        ctx.Outdent().WriteLine($"case {subTag}:").Indent();
                    }

                    if (field.FValueType == xpFieldTypes.Type_Message)
                        ctx.WriteLine($"Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().Read(ref ctx, ref {Escape(field.Name)}, {field.Tag});");
                    else if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"Repeated{funcSubName}<{Escape(field.FValueTypeName)}>().Read(ref ctx, ref {Escape(field.Name)}, {field.Tag});");
                    else
                        ctx.WriteLine($"Repeated{funcSubName}().Read(ref ctx, ref {Escape(field.Name)}, {field.Tag});");
                }
                else if (field.Collections == FieldCollections.Map)
                {
                    ctx.WriteLine($"_{ToCamelCase(field.Name)}_codec.Read(ref ctx, ref {Escape(field.Name)});");
                }
                else if (field.FValueType == xpFieldTypes.Type_Message)
                {
                    if (field.Name == "MetaNestedData")
                    {
                        ctx.WriteLine($"ctx.ReadMessage({Escape(field.Name)});");
                    }
                    else
                    {
                        ctx.WriteLine($"if ({Escape(field.Name)} == null)").Indent();
                        ctx.WriteLine($"{Escape(field.Name)} = new {Escape(field.FValueTypeName)}();").Outdent();
                        ctx.WriteLine($"ctx.ReadMessage({Escape(field.Name)});");
                    }
                }
                else
                {
                    if (field.FValueType == xpFieldTypes.Type_Enum)
                        ctx.WriteLine($"{Escape(field.Name)} = ({Escape(field.FValueTypeName)})ctx.Read{funcSubName}();");
                    else if (field.FValueType == xpFieldTypes.Type_DateTime)
                        ctx.WriteLine($"{Escape(field.Name)} = ToDateTime(ctx.ReadUInt64());");
                    else if (field.FValueType == xpFieldTypes.Type_TimeSpan)
                        ctx.WriteLine($"{Escape(field.Name)} = TimeSpan.FromTicks(ctx.ReadInt64());");
                    else if (field.FValueType == xpFieldTypes.Type_Uri)
                        ctx.WriteLine($"{Escape(field.Name)} = new Uri(ctx.ReadString());");
                    else if (field.FValueType == xpFieldTypes.Type_Guid)
                        ctx.WriteLine($"{Escape(field.Name)} = Guid.Parse(ctx.ReadString());");
                    else
                        ctx.WriteLine($"{Escape(field.Name)} = ctx.Read{funcSubName}();");
                }
                ctx.WriteLine($"break;").Outdent();
            }
            ctx.Outdent().WriteLine($"}}");
            ctx.Outdent().WriteLine($"}}");
            ctx.Outdent().WriteLine($"}}");
        }

        public void WriteProtobufFunction(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.WriteLine($"#region xpTURN.Protobuf.Method");
            WriteFuncConstructor(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncCopyConstructor(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncClone(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncEquals(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncEqualsMessage(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncGetHashCode(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncWriteToStream(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncInternalWriteTo(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncCalculateSize(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncMergeFrom(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncMergeFromStream(ctx, tableDef);
            ctx.WriteLine();
            WriteFuncInternalMergeFrom(ctx, tableDef);
            ctx.WriteLine($"#endregion");
        }

        public void WriteDataTableFunction(GeneratorContext ctx, TableDesc desc)
        {
            ctx.WriteLine($"#region Table");

            // Provide a method to get the ID or alias
            if (desc.IsNestedData)
            {
                var keyField = desc.GetKeyField();
                if (keyField != null)
                {
                    switch (keyField.FValueType)
                    {
                        case xpFieldTypes.Type_Int32:
                        case xpFieldTypes.Type_SInt32:
                        case xpFieldTypes.Type_SFixed32:
                            ctx.WriteLine($"override public int GetId() => {Escape(keyField.Name)};");
                            break;
                        case xpFieldTypes.Type_Enum:
                            ctx.WriteLine($"override public int GetId() => (int){Escape(keyField.Name)};");
                            break;
                        case xpFieldTypes.Type_String:
                            ctx.WriteLine($"override public string GetAlias() => {Escape(keyField.Name)};");
                            break;
                    }
                }
            }

            // If the table has a nested Map<NestedData> field, provide a property to access it
            if (desc.IsTable)
            {
                // If the Map<NestedData> field is dynamically loaded, provide a separate field unrelated to Protobuf
                // Provides a reference to the Map<NestedData> field, for access from shared logic
                FieldDesc nestedField = desc.GetNestedField();
                if (nestedField != null)
                {
                    ctx.WriteLine($"override public MetaNestedData GetMetaNestedData() => MetaNestedData;");

                    string csharpKeyTypeName = GetCSharpTypeName(nestedField.FKeyType, nestedField.FKeyTypeName);
                    string csharpValueTypeName = GetCSharpTypeName(nestedField.FValueType, nestedField.FValueTypeName);

                    var subName = GetMapKeySubName(nestedField.FKeyType);
                    var keyValueString = nestedField.FKeyType == xpFieldTypes.Type_Enum ? $"{csharpKeyTypeName}, {csharpValueTypeName}" : csharpValueTypeName;

                    var funcSubName = nestedField.FKeyType == xpFieldTypes.Type_String ? "Alias" : "";
                    var interfaceSubName = nestedField.FKeyType == xpFieldTypes.Type_String ? "String" : "Int";

                    if (desc.IsOnDemandField(nestedField))
                    {
                        ctx.WriteLine($"protected Dictionary<{csharpKeyTypeName}, {csharpValueTypeName}> {Escape(nestedField.Name)} {{ get; }} = new ();");
                    }

                    ctx.WriteLine($"override public IMap{interfaceSubName}Wrapper GetMap{funcSubName}() => MetaNestedData.Map{interfaceSubName}Wrapper;");
                }
            }

            // Get reference properties for fields ending with 'RefId'
            if (desc.IsMessage)
            {
                // Provide a property for each field ending with 'RefId' that has a 'Get' option
                foreach (var field in desc.GetListField())
                {
                    if (string.IsNullOrEmpty(field.ParsedExtraOpts.Get))
                        continue;

                    if (!field.Name.EndsWith(sRefID))
                    {
                        Logger.Log.Tool.Error(field.DebugInfo, $"Field '{field.Name}' does not end with '{sRefID}'. The 'Get' option is only valid for fields ending with '{sRefID}'.");
                        continue;
                    }

                    var getType = field.ParsedExtraOpts.Get.Trim();
                    if (CheckGetterType(getType) == false)
                    {
                        // Log a warning if the 'Get' type is invalid. 
                        // Only a warning is output, considering the case where the user manually implements the Get function.
                        Logger.Log.Tool.Warn(field.DebugInfo, $"Invalid 'Get' type '{getType}' for field '{field.Name}'.");
                    }
                
                    var propName = Escape(field.Name.Substring(0, field.Name.Length - sRefID.Length));
                    if (desc.GetListField().Any(f => f.Name == propName))
                    {
                        Logger.Log.Tool.Error(field.DebugInfo, $"Property name '{propName}' conflicts with another field.");
                        continue;
                    }

                    if (field.Collections == FieldCollections.None && TableTypeUtils.IsIntKeyType(field.FValueType))
                    {
                        ctx.WriteLine($"[IgnoreDataMember]");
                        ctx.WriteLine($"public {getType} {propName} => Instance.Get{getType}({Escape(field.Name)});");
                    }

                    if (field.Collections == FieldCollections.List && TableTypeUtils.IsIntKeyType(field.FValueType))
                    {
                        ctx.WriteLine($"[IgnoreDataMember]");
                        ctx.WriteLine($"public ListIntGetter<{getType}> {propName} {{ get; }} = new (null, id => Instance.Get{getType}(id));");
                    }
                }
            }
            ctx.WriteLine($"#endregion");
        }
        
        public void WriteFieldTagComment(GeneratorContext ctx, TableDesc table, FieldDesc field)
        {
            if (field.Collections == FieldCollections.Map)
            {
                ctx.WriteLine($"// {Escape(field.Name)}: Tag({field.Tag}) = {field.Num} << 3 | {(int)field.WireType}");
                ctx.WriteLine($"//     keyTag({field.KeyTag}) = 1 << 3 | {(int)field.KeyWireType}");
                ctx.WriteLine($"//     valueTag({field.ValueTag}) = 2 << 3 | {(int)field.ValueWireType}");
            }
            else
            {
                ctx.WriteLine($"// {Escape(field.Name)}: Tag({field.Tag}) = {field.Num} << 3 | {(int)field.WireType}");
            }
        }

        public void WriteField(GeneratorContext ctx, TableDesc table, FieldDesc field)
        {
            string __defaultValue = field.Default;
            if (!GetCSharpDefaultValue(field.Collections, field.FValueType, ref __defaultValue))
            {
                Logger.Log.Tool.Error(field.DebugInfo, $"Unknown Default Value '{field.Default}'");
            }

            string csharpKeyTypeName = GetCSharpTypeName(field.FKeyType, field.FKeyTypeName);
            string csharpValueTypeName = GetCSharpTypeName(field.FValueType, field.FValueTypeName);
            string defaultValueString = string.IsNullOrEmpty(__defaultValue) ? "" : $" = {__defaultValue}";

            if (field.Obsolete == FieldObsolete.Warning)
            {
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\")]");
            }
            else if (field.Obsolete == FieldObsolete.Error)
            {
                ctx.WriteLine($"[Obsolete(\"This field has been deprecated.\", true)]");
            }

            if (field.Collections == FieldCollections.List)
            {
                ctx.WriteLine($"public List<{csharpValueTypeName}> {Escape(field.Name)} = new ();");
            }
            else if (field.Collections == FieldCollections.Map)
            {
                if (table.IsTable && table.IsWeakField(field))
                {
                    ctx.WriteLine($"[JsonInclude]");
                    ctx.WriteLine($"protected Dictionary<{csharpKeyTypeName}, {csharpValueTypeName}> {Escape(field.Name)} = new ();");
                }
                else
                {
                    ctx.WriteLine($"public Dictionary<{csharpKeyTypeName}, {csharpValueTypeName}> {Escape(field.Name)} = new ();");
                }
            }
            else if (field.FValueType == xpFieldTypes.Type_Message)
            {
                if (field.Name == "MetaNestedData")
                    ctx.WriteLine($"public {csharpValueTypeName} {Escape(field.Name)} = new {Escape(field.Name)}();");
                else
                    ctx.WriteLine($"public {csharpValueTypeName} {Escape(field.Name)} = null;");
            }
            else
            {
                ctx.WriteLine($"public {csharpValueTypeName} {Escape(field.Name)}{defaultValueString};");
            }
        }

        public string GetFieldCodec(xpFieldTypes fType, string typeName, uint tag)
        {
            string codec;
            string csharpTypeName = GetCSharpTypeName(fType, typeName);
            GetCSharpDefaultValueByType(fType, typeName, out _);
            var funcSubName = GetGoogleTypeName(fType);

            if (fType == xpFieldTypes.Type_Message)
            {
                codec = $"xpFieldCodecForMessage<{csharpTypeName}>.{funcSubName}Codec";
            }
            else if (fType == xpFieldTypes.Type_Enum)
            {
                codec = $"xpFieldCodecForEnum<{csharpTypeName}>.EnumCodec";
            }
            else
            {
                codec = $"xpFieldHelper.{funcSubName}Codec";
            }

            return codec;
        }

        public void WriteParserField(GeneratorContext ctx, FieldDesc field)
        {
            string csharpKeyTypeName = GetCSharpTypeName(field.FKeyType, field.FKeyTypeName);
            string csharpValueTypeName = GetCSharpTypeName(field.FValueType, field.FValueTypeName);

            if (field.Collections == FieldCollections.Map)
            {
                string forKeyCodec = GetFieldCodec(field.FKeyType, field.FKeyTypeName, field.KeyTag);
                string forValueCodec = GetFieldCodec(field.FValueType, field.FValueTypeName, field.ValueTag);

                ctx.WriteLine($"protected static readonly xpMapCodec<{csharpKeyTypeName}, {csharpValueTypeName}> _{ToCamelCase(field.Name)}_codec");
                ctx.Indent().WriteLine($"= new ({forKeyCodec}, {forValueCodec}, {field.Tag}, {field.KeyTag}, {field.ValueTag});").Outdent();
            }
        }

        public void WriteMessageFooter(GeneratorContext ctx, TableDesc tableDef)
        {
            ctx.Outdent().WriteLine($"}}");
            ctx.WriteLine();
        }

        public void WriteMessage(GeneratorContext ctx, TableDesc tableDef)
        {
            WriteComments(ctx, tableDef);
            WriteMessageHeader(ctx, tableDef);

            ctx.WriteLine($"#region Proto.Field");
            if (bool.TryParse(ctx.GetCustomOption("TagComment"), out var tagComment) && tagComment)
            {
                ctx.WriteLine($"// Field definitions for {Escape(tableDef.Name)}");
                foreach (var field in tableDef.GetListField())
                {
                    if (tableDef.IsOnDemandField(field))
                        continue;
                    WriteFieldTagComment(ctx, tableDef,field);
                }
                ctx.WriteLine();
            }

            foreach (var field in tableDef.GetListField())
            {
                if (tableDef.IsOnDemandField(field))
                    continue;

                WriteComments(ctx, field);
                WriteField(ctx, tableDef, field);
            }

            ctx.WriteLine($"#endregion");

            ctx.WriteLine();

            var mapFields = tableDef.GetListField().FindAll(field => field.Collections == FieldCollections.Map);
            if (mapFields.Count > 0)
            {
                ctx.WriteLine($"#region Paser.Field");
                foreach (var field in mapFields)
                {
                    WriteParserField(ctx, field);
                }
                ctx.WriteLine($"#endregion");
                ctx.WriteLine();
            }

            WriteProtobufFunction(ctx, tableDef);

            if (ctx.IsEnabled("ForDataTable") && (tableDef.IsTable || tableDef.IsData))
            {
                ctx.WriteLine();
                WriteDataTableFunction(ctx, tableDef);
            }

            WriteMessageFooter(ctx, tableDef);
        }

        protected void WriteBuffer(GeneratorContext ctx)
        {
            //
            WriteFileHeader(ctx);

            //
            var listMsg = _listTable.FindAll(item => item.IsMessage);
            foreach (var table in listMsg)
            {
                //
                Logger.Log.Info($"{table.Type.ToString().PadRight(12)}'{table.Name}'");
                WriteMessage(ctx, table);
            }

            var listEnum = _listTable.FindAll(item => item.IsEnum);
            foreach (var table in listEnum)
            {
                //
                Logger.Log.Info($"{table.Type.ToString().PadRight(12)}'{table.Name}'");
                WriteEnum(ctx, table);
            }

            //
            WriteFileFooter(ctx);
        }

        public string ExportFile(GeneratorContext ctx, string fileName, List<TableDesc> listTable)
        {
            _listTable = listTable;
            string generated = string.Empty;
            {
                WriteBuffer(ctx);
                generated = ctx.Output.ToString();
            }

            //
            //
            using (var writer = File.CreateText(fileName))
            {
                writer.Write(generated);
            }
        
            return MD5Utils.ComputeMD5Hash(generated);
        }
    }
}
