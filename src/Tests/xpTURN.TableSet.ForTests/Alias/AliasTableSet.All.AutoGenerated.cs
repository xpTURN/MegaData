// <auto-generated>
//   This file was generated by a tool; you should avoid making direct changes.
//   Consider using 'partial classes' to extend these types
// </auto-generated>

#region Designer generated code
#nullable disable
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

using xpTURN.Common;
using xpTURN.Protobuf;
using xpTURN.Protobuf.Collections;
using static xpTURN.Protobuf.Collections.ProtobufEqualityComparers;
using static xpTURN.Protobuf.CodedOutputStream;
using static xpTURN.Protobuf.xpRepeatedFieldHelper;
using static xpTURN.Protobuf.xpDateTimeUtils;
using xpTURN.MegaData;
using static Tests.Alias.AliasTableSet;

namespace Tests.Alias
{
    public partial class DepthDataTable : Table, IMessage<DepthDataTable>, IBufferMessage
    {
        #region Proto.Field
        public Dictionary<string, FirstData> Map = new ();
        public MetaNestedData MetaNestedData = new MetaNestedData();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<string, FirstData> _map_codec
            = new (xpFieldHelper.StringCodec, xpFieldCodecForMessage<FirstData>.MessageCodec, 10, 10, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public DepthDataTable()
        {
            MetaNestedData.SetupStringWrapper(new MapStringWrapper<FirstData>(Map));
        }

        public DepthDataTable(DepthDataTable other) : this()
        {
            Map = _map_codec.Clone(other.Map);
            if (other.MetaNestedData != null) MetaNestedData = other.MetaNestedData.Clone();
            MetaNestedData.SetupStringWrapper(new MapStringWrapper<FirstData>(Map));
        }

        public DepthDataTable Clone()
        {
            return new DepthDataTable(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as DepthDataTable);
        }

        public bool Equals(DepthDataTable other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (!_map_codec.AreEqual(Map, other.Map)) return false;
            if (!object.Equals(MetaNestedData, other.MetaNestedData)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= _map_codec.GetHashCode(Map);
            if (MetaNestedData != null) hash ^= MetaNestedData.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            _map_codec.WriteTo(ref ctx, ref Map);
            if (MetaNestedData != null)
            {
                ctx.WriteRawTag(186, 163, 9);
                ctx.WriteMessage(MetaNestedData);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            size += _map_codec.CalculateSize(Map);
            if (MetaNestedData != null)
            {
                size += 3 + CodedOutputStream.ComputeMessageSize(MetaNestedData);
            }
            return size;
        }

        public void MergeFrom(DepthDataTable other)
        {
            if (other == null)
            {
                return;
            }
            _map_codec.Merge(Map, other.Map);
            if (other.MetaNestedData != null)
            {
                if (MetaNestedData == null)
                    MetaNestedData = new MetaNestedData();
                MetaNestedData.MergeFrom(other.MetaNestedData);
            }
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        _map_codec.Read(ref ctx, ref Map);
                        break;
                    case 151994:
                        ctx.ReadMessage(MetaNestedData);
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public MetaNestedData GetMetaNestedData() => MetaNestedData;
        override public IMapStringWrapper GetMapAlias() => MetaNestedData.MapStringWrapper;
        #endregion
    }

    public partial class FirstData : Data, IMessage<FirstData>, IBufferMessage
    {
        #region Proto.Field
        public string Alias = "";
        public Dictionary<string, SecondData> SecondMap = new ();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<string, SecondData> _secondMap_codec
            = new (xpFieldHelper.StringCodec, xpFieldCodecForMessage<SecondData>.MessageCodec, 42, 10, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public FirstData()
        {
        }

        public FirstData(FirstData other) : this()
        {
            Alias = other.Alias;
            SecondMap = _secondMap_codec.Clone(other.SecondMap);
        }

        public FirstData Clone()
        {
            return new FirstData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as FirstData);
        }

        public bool Equals(FirstData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Alias != other.Alias) return false;
            if (!_secondMap_codec.AreEqual(SecondMap, other.SecondMap)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Alias.Length != 0) hash ^= Alias.GetHashCode();
            hash ^= _secondMap_codec.GetHashCode(SecondMap);
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Alias.Length != 0)
            {
                ctx.WriteRawTag(10);
                ctx.WriteString(Alias);
            }
            _secondMap_codec.WriteTo(ref ctx, ref SecondMap);
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Alias.Length != 0)
            {
                size += 1 + ComputeStringSize(Alias);
            }
            size += _secondMap_codec.CalculateSize(SecondMap);
            return size;
        }

        public void MergeFrom(FirstData other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Alias.Length != 0)
            {
                Alias = other.Alias;
            }
            _secondMap_codec.Merge(SecondMap, other.SecondMap);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        Alias = ctx.ReadString();
                        break;
                    case 42:
                        _secondMap_codec.Read(ref ctx, ref SecondMap);
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public string GetAlias() => Alias;
        #endregion
    }

    public partial class SecondData : Data, IMessage<SecondData>, IBufferMessage
    {
        #region Proto.Field
        public string Alias = "";
        public string Second1 = "";
        public string Second2 = "";
        public Dictionary<string, ThirdData> ThirdMap = new ();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<string, ThirdData> _thirdMap_codec
            = new (xpFieldHelper.StringCodec, xpFieldCodecForMessage<ThirdData>.MessageCodec, 50, 10, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public SecondData()
        {
        }

        public SecondData(SecondData other) : this()
        {
            Alias = other.Alias;
            Second1 = other.Second1;
            Second2 = other.Second2;
            ThirdMap = _thirdMap_codec.Clone(other.ThirdMap);
        }

        public SecondData Clone()
        {
            return new SecondData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as SecondData);
        }

        public bool Equals(SecondData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Alias != other.Alias) return false;
            if (Second1 != other.Second1) return false;
            if (Second2 != other.Second2) return false;
            if (!_thirdMap_codec.AreEqual(ThirdMap, other.ThirdMap)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Alias.Length != 0) hash ^= Alias.GetHashCode();
            if (Second1.Length != 0) hash ^= Second1.GetHashCode();
            if (Second2.Length != 0) hash ^= Second2.GetHashCode();
            hash ^= _thirdMap_codec.GetHashCode(ThirdMap);
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Alias.Length != 0)
            {
                ctx.WriteRawTag(10);
                ctx.WriteString(Alias);
            }
            if (Second1.Length != 0)
            {
                ctx.WriteRawTag(18);
                ctx.WriteString(Second1);
            }
            if (Second2.Length != 0)
            {
                ctx.WriteRawTag(26);
                ctx.WriteString(Second2);
            }
            _thirdMap_codec.WriteTo(ref ctx, ref ThirdMap);
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Alias.Length != 0)
            {
                size += 1 + ComputeStringSize(Alias);
            }
            if (Second1.Length != 0)
            {
                size += 1 + ComputeStringSize(Second1);
            }
            if (Second2.Length != 0)
            {
                size += 1 + ComputeStringSize(Second2);
            }
            size += _thirdMap_codec.CalculateSize(ThirdMap);
            return size;
        }

        public void MergeFrom(SecondData other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Alias.Length != 0)
            {
                Alias = other.Alias;
            }
            if (other.Second1.Length != 0)
            {
                Second1 = other.Second1;
            }
            if (other.Second2.Length != 0)
            {
                Second2 = other.Second2;
            }
            _thirdMap_codec.Merge(ThirdMap, other.ThirdMap);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        Alias = ctx.ReadString();
                        break;
                    case 18:
                        Second1 = ctx.ReadString();
                        break;
                    case 26:
                        Second2 = ctx.ReadString();
                        break;
                    case 50:
                        _thirdMap_codec.Read(ref ctx, ref ThirdMap);
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public string GetAlias() => Alias;
        #endregion
    }

    public partial class ThirdData : Data, IMessage<ThirdData>, IBufferMessage
    {
        #region Proto.Field
        public string Alias = "";
        public string Third1 = "";
        public string Third2 = "";
        #endregion

        #region xpTURN.Protobuf.Method
        public ThirdData()
        {
        }

        public ThirdData(ThirdData other) : this()
        {
            Alias = other.Alias;
            Third1 = other.Third1;
            Third2 = other.Third2;
        }

        public ThirdData Clone()
        {
            return new ThirdData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as ThirdData);
        }

        public bool Equals(ThirdData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Alias != other.Alias) return false;
            if (Third1 != other.Third1) return false;
            if (Third2 != other.Third2) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Alias.Length != 0) hash ^= Alias.GetHashCode();
            if (Third1.Length != 0) hash ^= Third1.GetHashCode();
            if (Third2.Length != 0) hash ^= Third2.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Alias.Length != 0)
            {
                ctx.WriteRawTag(10);
                ctx.WriteString(Alias);
            }
            if (Third1.Length != 0)
            {
                ctx.WriteRawTag(18);
                ctx.WriteString(Third1);
            }
            if (Third2.Length != 0)
            {
                ctx.WriteRawTag(26);
                ctx.WriteString(Third2);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Alias.Length != 0)
            {
                size += 1 + ComputeStringSize(Alias);
            }
            if (Third1.Length != 0)
            {
                size += 1 + ComputeStringSize(Third1);
            }
            if (Third2.Length != 0)
            {
                size += 1 + ComputeStringSize(Third2);
            }
            return size;
        }

        public void MergeFrom(ThirdData other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Alias.Length != 0)
            {
                Alias = other.Alias;
            }
            if (other.Third1.Length != 0)
            {
                Third1 = other.Third1;
            }
            if (other.Third2.Length != 0)
            {
                Third2 = other.Third2;
            }
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        Alias = ctx.ReadString();
                        break;
                    case 18:
                        Third1 = ctx.ReadString();
                        break;
                    case 26:
                        Third2 = ctx.ReadString();
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public string GetAlias() => Alias;
        #endregion
    }

}
#nullable restore
#endregion
