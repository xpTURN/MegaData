// <auto-generated>
//   This file was generated by a tool; you should avoid making direct changes.
//   Consider using 'partial classes' to extend these types
// </auto-generated>

#region Designer generated code
#nullable disable
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

using xpTURN.Common;
using xpTURN.Protobuf;
using xpTURN.Protobuf.Collections;
using static xpTURN.Protobuf.Collections.ProtobufEqualityComparers;
using static xpTURN.Protobuf.CodedOutputStream;
using static xpTURN.Protobuf.xpRepeatedFieldHelper;
using static xpTURN.Protobuf.xpDateTimeUtils;
using xpTURN.MegaData;
using static Tests.Locale.Type2.Locale2TableSet;

namespace Tests.Locale.Type2
{
    public partial class LocaleDataTable : Table, IMessage<LocaleDataTable>, IBufferMessage
    {
        #region Proto.Field
        public MetaNestedData MetaNestedData = new MetaNestedData();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<int, TextDataTable> _map_codec
            = new (xpFieldHelper.Int32Codec, xpFieldCodecForMessage<TextDataTable>.MessageCodec, 10, 8, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public LocaleDataTable()
        {
            MetaNestedData.SetupIntWrapper(new MapIntWrapper<TextDataTable>(Map), Instance.EnableWeakRef);
        }

        public LocaleDataTable(LocaleDataTable other) : this()
        {
            if (other.MetaNestedData != null) MetaNestedData = other.MetaNestedData.Clone();
            MetaNestedData.SetupIntWrapper(new MapIntWrapper<TextDataTable>(Map), Instance.EnableWeakRef);
        }

        public LocaleDataTable Clone()
        {
            return new LocaleDataTable(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as LocaleDataTable);
        }

        public bool Equals(LocaleDataTable other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (!object.Equals(MetaNestedData, other.MetaNestedData)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (MetaNestedData != null) hash ^= MetaNestedData.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (MetaNestedData != null)
            {
                ctx.WriteRawTag(186, 163, 9);
                ctx.WriteMessage(MetaNestedData);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (MetaNestedData != null)
            {
                size += 3 + CodedOutputStream.ComputeMessageSize(MetaNestedData);
            }
            return size;
        }

        public void MergeFrom(LocaleDataTable other)
        {
            if (other == null)
            {
                return;
            }
            if (other.MetaNestedData != null)
            {
                if (MetaNestedData == null)
                    MetaNestedData = new MetaNestedData();
                MetaNestedData.MergeFrom(other.MetaNestedData);
            }

            _map_codec.Merge(Map, other.Map);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 151994:
                        ctx.ReadMessage(MetaNestedData);
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public MetaNestedData GetMetaNestedData() => MetaNestedData;
        protected Dictionary<int, TextDataTable> Map { get; } = new ();
        override public IMapIntWrapper GetMap() => MetaNestedData.MapIntWrapper;
        #endregion
    }

    public partial class TextData : Data, IMessage<TextData>, IBufferMessage
    {
        #region Proto.Field
        public int Id;
        public string IdAlias = "";
        public string Text = "";
        #endregion

        #region xpTURN.Protobuf.Method
        public TextData()
        {
        }

        public TextData(TextData other) : this()
        {
            Id = other.Id;
            IdAlias = other.IdAlias;
            Text = other.Text;
        }

        public TextData Clone()
        {
            return new TextData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as TextData);
        }

        public bool Equals(TextData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Id != other.Id) return false;
            if (IdAlias != other.IdAlias) return false;
            if (Text != other.Text) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Id != 0) hash ^= Id.GetHashCode();
            if (IdAlias.Length != 0) hash ^= IdAlias.GetHashCode();
            if (Text.Length != 0) hash ^= Text.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Id != 0)
            {
                ctx.WriteRawTag(8);
                ctx.WriteInt32(Id);
            }
            if (IdAlias.Length != 0)
            {
                ctx.WriteRawTag(18);
                ctx.WriteString(IdAlias);
            }
            if (Text.Length != 0)
            {
                ctx.WriteRawTag(26);
                ctx.WriteString(Text);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Id != 0)
            {
                size += 1 + ComputeInt32Size(Id);
            }
            if (IdAlias.Length != 0)
            {
                size += 1 + ComputeStringSize(IdAlias);
            }
            if (Text.Length != 0)
            {
                size += 1 + ComputeStringSize(Text);
            }
            return size;
        }

        public void MergeFrom(TextData other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Id != 0)
            {
                Id = other.Id;
            }
            if (other.IdAlias.Length != 0)
            {
                IdAlias = other.IdAlias;
            }
            if (other.Text.Length != 0)
            {
                Text = other.Text;
            }
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 8:
                        Id = ctx.ReadInt32();
                        break;
                    case 18:
                        IdAlias = ctx.ReadString();
                        break;
                    case 26:
                        Text = ctx.ReadString();
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public int GetId() => Id;
        #endregion
    }

    public partial class TextDataTable : Table, IMessage<TextDataTable>, IBufferMessage
    {
        #region Proto.Field
        public int Id;
        public MetaNestedData MetaNestedData = new MetaNestedData();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<int, TextData> _map_codec
            = new (xpFieldHelper.Int32Codec, xpFieldCodecForMessage<TextData>.MessageCodec, 18, 8, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public TextDataTable()
        {
            MetaNestedData.SetupIntWrapper(new MapIntWrapper<TextData>(Map), Instance.EnableWeakRef);
        }

        public TextDataTable(TextDataTable other) : this()
        {
            Id = other.Id;
            if (other.MetaNestedData != null) MetaNestedData = other.MetaNestedData.Clone();
            MetaNestedData.SetupIntWrapper(new MapIntWrapper<TextData>(Map), Instance.EnableWeakRef);
        }

        public TextDataTable Clone()
        {
            return new TextDataTable(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as TextDataTable);
        }

        public bool Equals(TextDataTable other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Id != other.Id) return false;
            if (!object.Equals(MetaNestedData, other.MetaNestedData)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Id != 0) hash ^= Id.GetHashCode();
            if (MetaNestedData != null) hash ^= MetaNestedData.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Id != 0)
            {
                ctx.WriteRawTag(8);
                ctx.WriteInt32(Id);
            }
            if (MetaNestedData != null)
            {
                ctx.WriteRawTag(186, 163, 9);
                ctx.WriteMessage(MetaNestedData);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Id != 0)
            {
                size += 1 + ComputeInt32Size(Id);
            }
            if (MetaNestedData != null)
            {
                size += 3 + CodedOutputStream.ComputeMessageSize(MetaNestedData);
            }
            return size;
        }

        public void MergeFrom(TextDataTable other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Id != 0)
            {
                Id = other.Id;
            }
            if (other.MetaNestedData != null)
            {
                if (MetaNestedData == null)
                    MetaNestedData = new MetaNestedData();
                MetaNestedData.MergeFrom(other.MetaNestedData);
            }

            _map_codec.Merge(Map, other.Map);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 8:
                        Id = ctx.ReadInt32();
                        break;
                    case 151994:
                        ctx.ReadMessage(MetaNestedData);
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public int GetId() => Id;
        override public MetaNestedData GetMetaNestedData() => MetaNestedData;
        protected Dictionary<int, TextData> Map { get; } = new ();
        override public IMapIntWrapper GetMap() => MetaNestedData.MapIntWrapper;
        #endregion
    }

    public partial class TranslatedData : Data, IMessage<TranslatedData>, IBufferMessage
    {
        #region Proto.Field
        public int Id;
        public string IdAlias = "";
        public Dictionary<string, string> Map = new ();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<string, string> _map_codec
            = new (xpFieldHelper.StringCodec, xpFieldHelper.StringCodec, 26, 10, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public TranslatedData()
        {
        }

        public TranslatedData(TranslatedData other) : this()
        {
            Id = other.Id;
            IdAlias = other.IdAlias;
            Map = _map_codec.Clone(other.Map);
        }

        public TranslatedData Clone()
        {
            return new TranslatedData(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as TranslatedData);
        }

        public bool Equals(TranslatedData other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (Id != other.Id) return false;
            if (IdAlias != other.IdAlias) return false;
            if (!_map_codec.AreEqual(Map, other.Map)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            if (Id != 0) hash ^= Id.GetHashCode();
            if (IdAlias.Length != 0) hash ^= IdAlias.GetHashCode();
            hash ^= _map_codec.GetHashCode(Map);
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            if (Id != 0)
            {
                ctx.WriteRawTag(13);
                ctx.WriteSFixed32(Id);
            }
            if (IdAlias.Length != 0)
            {
                ctx.WriteRawTag(18);
                ctx.WriteString(IdAlias);
            }
            _map_codec.WriteTo(ref ctx, ref Map);
        }

        public int CalculateSize()
        {
            int size = 0;
            if (Id != 0)
            {
                size += 1 + ComputeSFixed32Size(Id);
            }
            if (IdAlias.Length != 0)
            {
                size += 1 + ComputeStringSize(IdAlias);
            }
            size += _map_codec.CalculateSize(Map);
            return size;
        }

        public void MergeFrom(TranslatedData other)
        {
            if (other == null)
            {
                return;
            }
            if (other.Id != 0)
            {
                Id = other.Id;
            }
            if (other.IdAlias.Length != 0)
            {
                IdAlias = other.IdAlias;
            }
            _map_codec.Merge(Map, other.Map);
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 13:
                        Id = ctx.ReadSFixed32();
                        break;
                    case 18:
                        IdAlias = ctx.ReadString();
                        break;
                    case 26:
                        _map_codec.Read(ref ctx, ref Map);
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public int GetId() => Id;
        #endregion
    }

    public partial class TranslatedDataTable : Table, IMessage<TranslatedDataTable>, IBufferMessage
    {
        #region Proto.Field
        public Dictionary<int, TranslatedData> Map = new ();
        public MetaNestedData MetaNestedData = new MetaNestedData();
        #endregion

        #region Paser.Field
        protected static readonly xpMapCodec<int, TranslatedData> _map_codec
            = new (xpFieldHelper.SFixed32Codec, xpFieldCodecForMessage<TranslatedData>.MessageCodec, 10, 13, 18);
        #endregion

        #region xpTURN.Protobuf.Method
        public TranslatedDataTable()
        {
            MetaNestedData.SetupIntWrapper(new MapIntWrapper<TranslatedData>(Map));
        }

        public TranslatedDataTable(TranslatedDataTable other) : this()
        {
            Map = _map_codec.Clone(other.Map);
            if (other.MetaNestedData != null) MetaNestedData = other.MetaNestedData.Clone();
            MetaNestedData.SetupIntWrapper(new MapIntWrapper<TranslatedData>(Map));
        }

        public TranslatedDataTable Clone()
        {
            return new TranslatedDataTable(this);
        }

        public override bool Equals(object other)
        {
            return Equals(other as TranslatedDataTable);
        }

        public bool Equals(TranslatedDataTable other)
        {
            if (ReferenceEquals(other, null)) return false;
            if (ReferenceEquals(other, this)) return true;

            if (!_map_codec.AreEqual(Map, other.Map)) return false;
            if (!object.Equals(MetaNestedData, other.MetaNestedData)) return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 1;
            hash ^= _map_codec.GetHashCode(Map);
            if (MetaNestedData != null) hash ^= MetaNestedData.GetHashCode();
            return hash;
        }

        public void WriteTo(CodedOutputStream output)
        {
            output.WriteRawMessage(this);
        }

        void IBufferMessage.InternalWriteTo(ref WriteContext ctx)
        {
            _map_codec.WriteTo(ref ctx, ref Map);
            if (MetaNestedData != null)
            {
                ctx.WriteRawTag(186, 163, 9);
                ctx.WriteMessage(MetaNestedData);
            }
        }

        public int CalculateSize()
        {
            int size = 0;
            size += _map_codec.CalculateSize(Map);
            if (MetaNestedData != null)
            {
                size += 3 + CodedOutputStream.ComputeMessageSize(MetaNestedData);
            }
            return size;
        }

        public void MergeFrom(TranslatedDataTable other)
        {
            if (other == null)
            {
                return;
            }
            _map_codec.Merge(Map, other.Map);
            if (other.MetaNestedData != null)
            {
                if (MetaNestedData == null)
                    MetaNestedData = new MetaNestedData();
                MetaNestedData.MergeFrom(other.MetaNestedData);
            }
        }

        public void MergeFrom(CodedInputStream input)
        {
            input.ReadRawMessage(this);
        }

        void IBufferMessage.InternalMergeFrom(ref ParseContext ctx)
        {
            uint tag;
            while ((tag = ctx.ReadTag()) != 0)
            {
                if ((tag & 7) == 4)
                {
                    // Abort on any end group tag.
                    return;
                }
                switch (tag)
                {
                    default:
                        xpParseUtils.SkipLastField(ref ctx);
                        break;
                    case 10:
                        _map_codec.Read(ref ctx, ref Map);
                        break;
                    case 151994:
                        ctx.ReadMessage(MetaNestedData);
                        break;
                }
            }
        }
        #endregion

        #region Table
        override public MetaNestedData GetMetaNestedData() => MetaNestedData;
        override public IMapIntWrapper GetMap() => MetaNestedData.MapIntWrapper;
        #endregion
    }

}
#nullable restore
#endregion
